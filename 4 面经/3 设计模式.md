[TOC]

# 设计模式

**几种基本原则**

* **开闭原则**：对象对于扩展是开放的，但是对于修改是封闭的
* **单一职责原则**：就一个类而言,应该仅有一个引起它变化的原因
* **高聚合原则**：面向对象编程的一个关键原则之一就是封装，把暴漏的数据封装起来，尽可能的让对象管理它们自己的状态，因为过多的依存性会造成紧耦合性系统，使得任意一点小的改动都可能造成许多无法预料的结果。而数据封装机制是一个控制对象数据和状态强有力的方法，它对外部世界隐藏其内部细节，这就意味着每一个对象都应该尽可能少的了解系统的其他部分或者被其他部分所了解，这样一来一旦发生了变化，需要了解这一个变化的对象会比较少，因此变化也就相对来说便于改动。
  * 内聚：内聚指的是一个模块内部各部分之间的关联程度，一个好的内聚模块应当只做好一件事
  * 耦合：耦合指各个对象之间的关联程度。
  * 封装原则：隐藏对象的属性和实现细节，仅对外公开接口，并且控制访问层级。
* **合成复用原则**：在软件复用时,要先尽量使用组合或者聚合等关联关系实现,其次才考虑使用继承。也就是在一个新对象里通过关联的方式使用已有对象的一些方法和功能。

![image-20210622172912436](images/image-20210622172912436.png)

**创建型模式**分为以下5种。（主要特点是“**将对象的创建与使用分离**”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节）

- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
- 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

**结构型模式**分为以下 7 种：（描述如何**将类或对象按某种布局组成更大的结构**。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。）

1. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
2. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
3. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
4. 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
5. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
6. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
7. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

**行为型模式**包含以下 11 种模式。（描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。）

1. 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
2. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
3. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
4. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
5. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
6. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
7. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
8. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
9. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
10. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
11. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。



## 1 单例模式

> 定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。

**特点**

* 单例类只有一个实例对象
* 该单例对象必须由单例类自行创建
* 单例类对外提供一个访问该单例的全局访问点

**优点**

* 可以保证内存中只有一个实例，减少了内存开销
* 可以避免对资源的多重占用
* 设置全局访问点，可以优化和共享资源的访问

**缺点**

* 一般没有接口，扩展困难。如果要扩展，除了修改原有代码，没有第二种方法，违背**开闭原则**（对象对于扩展是开放的，但是对于修改是封闭的）
* 并发测试中，单例不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生产一个新的对象
* 单例的功能代码通常写在一个类中，如果设计不合理，很容易违背**单一职责原则**。（单一职责原则: 就一个类而言,应该仅有一个引起它变化的原因）

**应用**

* Spring IOC Bean的默认模式
* JVM需要频繁创建的一些类，使用单例可以减少系统内存压力，减少GC
* 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。
* 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。

**实现**

1. 懒汉式：类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。
   		如果不删除这两个关键字还需要保证线程安全，每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。

   ```java
   public class LazySingleton {
       private static volatile LazySingleton instance = null;  // 保证在所有线程中同步
       
       private LazySingleton() {} // private避免类在外部被实例化
       
       public static synchronized LazySingleton getInstance() {
           if (instance == null) {
               instance = new LazySingleton();
           }
           return instance;
       }
   }
   ```

2. 饿汉式：类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了

   ```java
   public class HungrySingleton {
       private static final HungrySingleton instance = new HungrySingleton();
   
       private HungrySingleton() {
       }
   
       public static HungrySingleton getInstance() {
           return instance;
       }
   }
   ```



## 2 原型模式

> 定义：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象

**特点**：

* 原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。

**优点**

* Java自带的原型模式基于内存二进制流的复制，在性能上比直接new一个对象更好
* 可以使用深拷贝方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可以辅助实现撤销操作

**缺点**

* 需要为每一个类都配置一个clone方法
* clone方法在类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则
* 当实现深拷贝多重嵌套引用时，代码量较大，每一层对象对应的类都必须支持深拷贝

**应用**

* Spring IOC Bean的一种模式

**实现**

```java
//具体原型类
class Realizetype implements Cloneable {
    Realizetype() {
        System.out.println("具体原型创建成功！");
    }

    public Object clone() throws CloneNotSupportedException {
        System.out.println("具体原型复制成功！");
        return (Realizetype) super.clone();
    }
}

//原型模式的测试类
public class PrototypeTest {
    public static void main(String[] args) throws CloneNotSupportedException {
        Realizetype obj1 = new Realizetype();
        Realizetype obj2 = (Realizetype) obj1.clone();
        System.out.println("obj1==obj2?" + (obj1 == obj2));
    }
}
```



## 3 工厂模式

> 定义：定义一个创建对象的工厂接口，将对象的实际创建推送到具体工厂类中。
>
> 对象分为：抽象产品和具体产品（1）
>
> 工厂分为：抽象工厂和具体工厂（2）

**应用**

* Spring中的BeanFactory：BeanFactory定义了IOC容器的最基本形式，并提供了IOC容器应遵守的的最基本的接⼝，也就是Spring IOC所遵守的最底层和最基本的编程规范。在Spring代码中，BeanFactory只是个接⼝，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如ApplicationContext等，都是附加了某种功能的实现。
* Spring中的FactoryBean：Spring通过反射机制利⽤bean的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程⽐较复杂，如果按照传统的⽅式，则需要在bean中提供⼤量的配置信息。配置⽅式的灵活性是受限的，这时采⽤编码的⽅式可能会得到⼀个简单的⽅案。⽤户可以通过实现该接⼝定制实例化Bean的逻辑。

### 3.1 简单工厂模式

> 定义：要创建的对象不多，只要一个工厂类就可以完成（创建实例的方法通常为静态方法，所以也叫静态工厂方法模式）

**优点**

* 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个对象的实例。客户端可以免除直接创建产品对象的指责，从而更方便的创建出响应的产品。
* 客户端无需知道所创建具体对象的类型，只需要知道参数
* 可以引入配置文件，在不修改客户端代码的情况下更换和添加新的对象类

**缺点**

* 简单工厂模式的工厂类单一，负责所有产品的创建，一旦出现异常，整个系统将收到影响，且工厂类代码非常臃肿，违背高聚合原则
* 系统扩展问题，一旦增加新产品就需要修改工厂逻辑
* 简单工厂模式使用static工厂方法，造成工厂对象无法形成基于继承的等级结构

### 3.2 工厂方法模式

> 定义：简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。

**优点**

* 用户只需要知道具体工厂的名称就可以得到所要的对象，无须知道对象的具体创建过程
* 灵活性增强，对于新对象的创建，只需多写一个相应的工厂类
* 解耦。高层模块只需要知道对象的抽象类，不需要关心其他实现类。

**缺点**

* 抽象对象只能生成一种产品，可以使用抽象工厂模式解决

### 3.3 抽象工厂模式

> 定义：是工厂方法模式的升级版本，工厂方法模式中只有一个抽象产品类，而抽象工厂模式可有多个。

使用抽象工厂模式一般要满足以下条件。

- 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。
- 系统一次只可能消费其中某一族产品，即同族的产品一起使用。

**优点**

- 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
- 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
- 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。

**缺点**

* 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。

**应用**

* 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
* 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
* 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。



## 4 建造者模式

> 定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。
>
> 例子：客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修，最后完成整个客厅的装修与布局，所以本实例用建造者模式实现比较适合。

**优点**

* 封装性好，构建和表示分离
* 扩展性好，各个具体的建造者相互独立，有利于系统的解耦
* 客户端不需要知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响，便于控制细节风险

**缺点**

* 产品的组成部分必须相同，这限制了使用范围
* 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大

**对比工厂模式**

* 建造者模式更注重方法的调用顺序，工厂模式注重创建对象
* 创建对象的力度不同：建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的对象都一样
* 关注重点不一样：工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成
* 建造者模式根据建造过程中的顺序不一样，最终对象组件组成也不一样



## 5 代理模式

> 定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
>
> 例子：买票中介

**优点**

* 代理模式在客户端和目标对象之间起到一个中介作用和保护目标对象的作用
* 代理对象可以扩展目标对象的功能
* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性

**缺点**

* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢

**应用**

* Spring AOP
* 根据代理的创建时期，代理模式分为静态代理和动态代理。
  - 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。
  - 动态：在程序运行时，运用反射机制动态创建而成

```java
package proxy;

public class ProxyTest {
    public static void main(String[] args) {
        Proxy proxy = new Proxy();
        proxy.Request();
    }
}

//抽象主题
interface Subject {
    void Request();
}

//真实主题
class RealSubject implements Subject {
    public void Request() {
        System.out.println("访问真实主题方法...");
    }
}

//代理
class Proxy implements Subject {
    private RealSubject realSubject;

    public void Request() {
        if (realSubject == null) {
            realSubject = new RealSubject();
        }
        preRequest();
        realSubject.Request();
        postRequest();
    }

    public void preRequest() {
        System.out.println("访问真实主题之前的预处理。");
    }

    public void postRequest() {
        System.out.println("访问真实主题之后的后续处理。");
    }
}
```



## 6 适配器模式

> 定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为**类结构型模式**和**对象结构型模式**两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。
>
> 例子：讲中文的人同讲英文的人对话时需要一个翻译

**优点**

* 客户端通过适配器可以透明的调用目标接口
* 复用了现存的类，服务端不需要修改原有代码而重用现有的适配器类
* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题
* 开闭原则

**缺点**

* 适配器编写过程需要结合业务场景，会增加系统复杂性
* 过多使用适配器会使得系统代码变得凌乱

**应用**

* 类适配
  * 想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。
  * 有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。
* 接口适配
  * 要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器。

**实现**

1. 类适配器模式

```java
package adapter;
//目标接口
interface Target
{
    public void request();
}
//适配者接口
class Adaptee
{
    public void specificRequest()
    {       
        System.out.println("适配者中的业务代码被调用！");
    }
}
//类适配器类
class ClassAdapter extends Adaptee implements Target
{
    public void request()
    {
        specificRequest();
    }
}
//客户端代码
public class ClassAdapterTest
{
    public static void main(String[] args)
    {
        System.out.println("类适配器模式测试：");
        Target target = new ClassAdapter();
        target.request();
    }
}
```

2. 对象适配器模式

```java
package adapter;
//对象适配器类
class ObjectAdapter implements Target
{
    private Adaptee adaptee;
    public ObjectAdapter(Adaptee adaptee)
    {
        this.adaptee=adaptee;
    }
    public void request()
    {
        adaptee.specificRequest();
    }
}
//客户端代码
public class ObjectAdapterTest
{
    public static void main(String[] args)
    {
        System.out.println("对象适配器模式测试：");
        Adaptee adaptee = new Adaptee();
        Target target = new ObjectAdapter(adaptee);
        target.request();
    }
}
```



## 7 桥接模式

> 定义：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
>
> 例子：皮包有很多种，可以按用途分、按皮质分、按品牌分、按颜色分、按大小分等，存在多个维度的变化，所以采用桥接模式来实现女士皮包的选购比较合适。

**优点**

* 抽象与实现分离，扩展能力强
* 符合开闭原则
* 符合合成复用原则
* 实现细节对客户透明

**缺点**

* 由于聚合关系建立在抽象层，要求开发者对抽象化进行设计与编程，能正确的识别出系统中两个独立变化的维度，增加了系统的理解与设计难度

**应用**

* 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时
* 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时
* 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时

**实现**

```java
package bridge;

public class BridgeTest {
    public static void main(String[] args) {
        Implementor imple = new ConcreteImplementorA();
        Abstraction abs = new RefinedAbstraction(imple);
        abs.Operation();
    }
}

//实现化角色
interface Implementor {
    public void OperationImpl();
}

//具体实现化角色
class ConcreteImplementorA implements Implementor {
    public void OperationImpl() {
        System.out.println("具体实现化(Concrete Implementor)角色被访问");
    }
}

//抽象化角色
abstract class Abstraction {
    protected Implementor imple;

    protected Abstraction(Implementor imple) {
        this.imple = imple;
    }

    public abstract void Operation();
}

//扩展抽象化角色
class RefinedAbstraction extends Abstraction {
    protected RefinedAbstraction(Implementor imple) {
        super(imple);
    }

    public void Operation() {
        System.out.println("扩展抽象化(Refined Abstraction)角色被访问");
        imple.OperationImpl();
    }
}
```



## 8 装饰器模式

> 定义：在不改变现有对象结构的情况下，动态的给该对象增加一些指责（即增加其额外功能）的模式

**优点**

* 装饰器是继承的补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用
* 通过使用不用装饰器及这些装饰类的排列组合，可以实现不同效果
* 装饰器模式完全遵循开闭原则

**缺点**

* 子类过多，增加程序复杂性

**应用**

* Java I/O标准库

  * InputStream的子类FilterInputStream

    ```java
    BufferedReader in = new BufferedReader(new FileReader("filename.txt"));
    String s = in.readLine();
    ```

  * Reader的子类BufferedReader以及FilterReader

  * Writer的子类BufferedWriter、FilterWriter以及PrintWriter等

**实现**

```java
package decorator;

public class DecoratorPattern {
    public static void main(String[] args) {
        Component p = new ConcreteComponent();
        p.operation();
        System.out.println("---------------------------------");
        Component d = new ConcreteDecorator(p);
        d.operation();
    }
}

//抽象构件角色
interface Component {
    public void operation();
}

//具体构件角色
class ConcreteComponent implements Component {
    public ConcreteComponent() {
        System.out.println("创建具体构件角色");
    }

    public void operation() {
        System.out.println("调用具体构件角色的方法operation()");
    }
}

//抽象装饰角色
class Decorator implements Component {
    private Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    public void operation() {
        component.operation();
    }
}

//具体装饰角色
class ConcreteDecorator extends Decorator {
    public ConcreteDecorator(Component component) {
        super(component);
    }

    public void operation() {
        super.operation();
        addedFunction();
    }

    public void addedFunction() {
        System.out.println("为具体构件角色增加额外的功能addedFunction()");
    }
}
```



## 9 外观模式

> 定义：通过为多个复杂的子系统提供一个一致的接口，而使得这些子系统更加容易被访问。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节

**优点**

* 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响到它的客户类
* 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易
* 降低了大型软件系统中的编译依赖性

**缺点**

* 不能很好的限制客户使用子系统类，容易带来未知风险
* 增加新的子系统可能需要修改外观类或客户端的源码，违背开闭原则

**应用**

* 所有的大型系统都是这样。。。

```java
package facade;

public class FacadePattern {
    public static void main(String[] args) {
        Facade f = new Facade();
        f.method();
    }
}

//外观角色
class Facade {
    private SubSystem01 obj1 = new SubSystem01();
    private SubSystem02 obj2 = new SubSystem02();
    private SubSystem03 obj3 = new SubSystem03();

    public void method() {
        obj1.method1();
        obj2.method2();
        obj3.method3();
    }
}

//子系统角色
class SubSystem01 {
    public void method1() {
        System.out.println("子系统01的method1()被调用！");
    }
}

//子系统角色
class SubSystem02 {
    public void method2() {
        System.out.println("子系统02的method2()被调用！");
    }
}

//子系统角色
class SubSystem03 {
    public void method3() {
        System.out.println("子系统03的method3()被调用！");
    }
}
```



## 10 享元模式

> 定义：运用共享技术来有效支持大量细粒度对象的复用，通过共享已经存在的对象来大幅减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率
>
> **本质**：缓存共享对象，降低内存消耗

**优点**

* 相同对象只要保存一份，降低系统细粒度

**缺点**

* 为了使对象可以共享，需要将一些不能共享的状态外部化，这会增加程序的复杂度
* 读取享元模式的外部状态会加长运行时间

**应用**

* 各种公用类，常用类



## 11 组合模式

> 定义：也叫整体-部分模式，是一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性
>
> 例子：文件系统的文件和文件夹

**优点**

* 使得客户端代码可以一致的处理单个对象和组合对象，无须关心自己处理的是单个对象还是组合对象
* 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而改变源代码，满足“开闭原则”

**缺点**

* 设计复杂，需要时间理清类之间的层次关系
* 不易限制容器中的构件
* 不易用继承的方法来增加构件的新功能

**实现**

1. 透明方式：在该方式中，抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。
2. 安全方法：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了之前的安全性问题。但是由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性

```java
public class CompositePattern {
    public static void main(String[] args) {
        Component c0 = new Composite();
        Component c1 = new Composite();
        Component leaf1 = new Leaf("1");
        Component leaf2 = new Leaf("2");
        Component leaf3 = new Leaf("3");
        c0.add(leaf1);
        c0.add(c1);
        c1.add(leaf2);
        c1.add(leaf3);
        c0.operation();
    }
}

//抽象构件
interface Component {
    public void add(Component c);

    public void remove(Component c);

    public Component getChild(int i);

    public void operation();
}

//树叶构件
class Leaf implements Component {
    private String name;

    public Leaf(String name) {
        this.name = name;
    }

    public void add(Component c) {
    }

    public void remove(Component c) {
    }

    public Component getChild(int i) {
        return null;
    }

    public void operation() {
        System.out.println("树叶" + name + "：被访问！");
    }
}

//树枝构件
class Composite implements Component {
    private ArrayList<Component> children = new ArrayList<Component>();

    public void add(Component c) {
        children.add(c);
    }

    public void remove(Component c) {
        children.remove(c);
    }

    public Component getChild(int i) {
        return children.get(i);
    }

    public void operation() {
        for (Object obj : children) {
            ((Component) obj).operation();
        }
    }
}
```



## 12 模板方法模式

> 定义：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤
>
> 例子：多态

**优点**

* 把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
* 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则

**缺点**

* 对每个不同的实现都需要定义一个子类，会导致类的个数增加，系统更加庞大
* 如果父类添加新的抽象方法，则所有子类都要改一遍

```java
public class TemplateMethodPattern {
    public static void main(String[] args) {
        AbstractClass tm = new ConcreteClass();
        tm.TemplateMethod();
    }
}

//抽象类
abstract class AbstractClass {
    //模板方法
    public void TemplateMethod() {
        SpecificMethod();
        abstractMethod1();
        abstractMethod2();
    }

    //具体方法
    public void SpecificMethod() {
        System.out.println("抽象类中的具体方法被调用...");
    }

    //抽象方法1
    public abstract void abstractMethod1();

    //抽象方法2
    public abstract void abstractMethod2();
}

//具体子类
class ConcreteClass extends AbstractClass {
    public void abstractMethod1() {
        System.out.println("抽象方法1的实现被调用...");
    }

    public void abstractMethod2() {
        System.out.println("抽象方法2的实现被调用...");
    }
}
```



## 13 策略模式

> 定义：定义一系列算法，将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响算法的客户。
>
> 例子：开发中需要排序，可以冒泡、选排

**优点**

* 提供可供重用的算法族，使用继承可以把算法族的公共代码转移到父类里，从而避免重复的代码
* 提供相同行为的不同实现，客户可以根据需求选择不同的
* 对开闭的支持，在不修改原代码的情况下，灵活增加新算法

**缺点**

* 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法

```java
public class StrategyPattern {
    public static void main(String[] args) {
        Context c = new Context();
        Strategy s = new ConcreteStrategyA();
        c.setStrategy(s);
        c.strategyMethod();
        System.out.println("-----------------");
        s = new ConcreteStrategyB();
        c.setStrategy(s);
        c.strategyMethod();
    }
}

//抽象策略类
interface Strategy {
    public void strategyMethod();    //策略方法
}

//具体策略类A
class ConcreteStrategyA implements Strategy {
    public void strategyMethod() {
        System.out.println("具体策略A的策略方法被访问！");
    }
}

//具体策略类B
class ConcreteStrategyB implements Strategy {
    public void strategyMethod() {
        System.out.println("具体策略B的策略方法被访问！");
    }
}

//环境类
class Context {
    private Strategy strategy;

    public Strategy getStrategy() {
        return strategy;
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public void strategyMethod() {
        strategy.strategyMethod();
    }
}
```



## 14 命令模式

> 定义：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分开。这样两者之间通过命令对象进行沟通，方便将命令对象进行存储、传递、调用、增加与管理
>
> 例子：去餐厅吃饭，菜单不是等到客人来了之后才定制的，而是已经预先配置好的。这样，客人来了就只需要点菜，而不是任由客人临时定制。餐厅提供的菜单就相当于把请求和处理进行了解耦，这就是命令模式的体现

**优点**

* 通过引入中间件（抽象接口）降低系统的耦合度
* 拓展性良好，增加或删除命令方便
* 可以在现有命令的基础上，增加额外功能，比如日志记录，结合装饰器模式会更加灵活

**缺点**

* 命令模式的结果就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口）

```java
package command;

public class CommandPattern {
    public static void main(String[] args) {
        Command cmd = new ConcreteCommand();
        Invoker ir = new Invoker(cmd);
        System.out.println("客户访问调用者的call()方法...");
        ir.call();
    }
}

//调用者
class Invoker {
    private Command command;

    public Invoker(Command command) {
        this.command = command;
    }

    public void setCommand(Command command) {
        this.command = command;
    }

    public void call() {
        System.out.println("调用者执行命令command...");
        command.execute();
    }
}

//抽象命令
interface Command {
    public abstract void execute();
}

//具体命令
class ConcreteCommand implements Command {
    private Receiver receiver;

    ConcreteCommand() {
        receiver = new Receiver();
    }

    public void execute() {
        receiver.action();
    }
}

//接收者
class Receiver {
    public void action() {
        System.out.println("接收者的action()方法被调用...");
    }
}
```



## 15 责任链模式

> 定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

**优点**

* 降低了对象之间的耦合度，使得一个对象无须知道是哪一个对象处理其请求以及链的结构
* 增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
* 责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。

**缺点**

* 不能保证每个请求一定被处理，由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理
* 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致循环调用

```java
package chainOfResponsibility;

public class ChainOfResponsibilityPattern {
    public static void main(String[] args) {
        //组装责任链
        Handler handler1 = new ConcreteHandler1();
        Handler handler2 = new ConcreteHandler2();
        handler1.setNext(handler2);
        //提交请求
        handler1.handleRequest("two");
    }
}

//抽象处理者角色
abstract class Handler {
    private Handler next;

    public void setNext(Handler next) {
        this.next = next;
    }

    public Handler getNext() {
        return next;
    }

    //处理请求的方法
    public abstract void handleRequest(String request);
}

//具体处理者角色1
class ConcreteHandler1 extends Handler {
    public void handleRequest(String request) {
        if (request.equals("one")) {
            System.out.println("具体处理者1负责处理该请求！");
        } else {
            if (getNext() != null) {
                getNext().handleRequest(request);
            } else {
                System.out.println("没有人处理该请求！");
            }
        }
    }
}

//具体处理者角色2
class ConcreteHandler2 extends Handler {
    public void handleRequest(String request) {
        if (request.equals("two")) {
            System.out.println("具体处理者2负责处理该请求！");
        } else {
            if (getNext() != null) {
                getNext().handleRequest(request);
            } else {
                System.out.println("没有人处理该请求！");
            }
        }
    }
}
```



## 16 状态模式

> 定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发送改变时改变其行为

**优点**

* 结构清晰，将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足单一职责原则
* 将状态转换显式化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖

**缺点**

* 状态模式对开闭原则的支持并不友好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改相应类的源码

```java
public class StatePatternClient {
    public static void main(String[] args) {
        Context context = new Context();    //创建环境      
        context.Handle();    //处理请求
        context.Handle();
        context.Handle();
        context.Handle();
    }
}

//环境类
class Context {
    private State state;

    //定义环境类的初始状态
    public Context() {
        this.state = new ConcreteStateA();
    }

    //设置新状态
    public void setState(State state) {
        this.state = state;
    }

    //读取状态
    public State getState() {
        return (state);
    }

    //对请求做处理
    public void Handle() {
        state.Handle(this);
    }
}

//抽象状态类
abstract class State {
    public abstract void Handle(Context context);
}

//具体状态A类
class ConcreteStateA extends State {
    public void Handle(Context context) {
        System.out.println("当前状态是 A.");
        context.setState(new ConcreteStateB());
    }
}

//具体状态B类
class ConcreteStateB extends State {
    public void Handle(Context context) {
        System.out.println("当前状态是 B.");
        context.setState(new ConcreteStateA());
    }
}
```



## 17 观察者模式

> 定义：多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。也称为“**发布-订阅**模式”

**优点**

* 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系，符合依赖倒置原则
* 目标与观察者之间建立了一套触发机制

**缺点**

* 目标与观察者之间的依赖关系并没有完全解除，有可能出现循环引用
* 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率

```java
package net.biancheng.c.observer;

import java.util.*;

public class ObserverPattern {
    public static void main(String[] args) {
        Subject subject = new ConcreteSubject();
        Observer obs1 = new ConcreteObserver1();
        Observer obs2 = new ConcreteObserver2();
        subject.add(obs1);
        subject.add(obs2);
        subject.notifyObserver();
    }
}

//抽象目标
abstract class Subject {
    protected List<Observer> observers = new ArrayList<Observer>();

    //增加观察者方法
    public void add(Observer observer) {
        observers.add(observer);
    }

    //删除观察者方法
    public void remove(Observer observer) {
        observers.remove(observer);
    }

    public abstract void notifyObserver(); //通知观察者方法
}

//具体目标
class ConcreteSubject extends Subject {
    public void notifyObserver() {
        System.out.println("具体目标发生改变...");
        System.out.println("--------------");

        for (Object obs : observers) {
            ((Observer) obs).response();
        }

    }
}

//抽象观察者
interface Observer {
    void response(); //反应
}

//具体观察者1
class ConcreteObserver1 implements Observer {
    public void response() {
        System.out.println("具体观察者1作出反应！");
    }
}

//具体观察者1
class ConcreteObserver2 implements Observer {
    public void response() {
        System.out.println("具体观察者2作出反应！");
    }
}
```



## 18 中介者模式

> 定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互，也叫“调停模式”

**优点**

* 类之间各司其职，符合迪米特法则（最少知道原则,就是说一个对象应当对其它对象有尽可能少的了解,不要和陌生人说话。 强调只和朋友说话,不和陌生人说话。）
* 降低了对象之间的耦合性，使得对象易于独立地被复用
* 将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护

**缺点**

* 将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系，当同事类越多，中介者就会越臃肿，变得复杂且难以维护

```java
package net.biancheng.c.mediator;

import java.util.*;

public class MediatorPattern {
    public static void main(String[] args) {
        Mediator md = new ConcreteMediator();
        Colleague c1, c2;
        c1 = new ConcreteColleague1();
        c2 = new ConcreteColleague2();
        md.register(c1);
        md.register(c2);
        c1.send();
        System.out.println("-------------");
        c2.send();
    }
}

//抽象中介者
abstract class Mediator {
    public abstract void register(Colleague colleague);

    public abstract void relay(Colleague cl); //转发
}

//具体中介者
class ConcreteMediator extends Mediator {
    private List<Colleague> colleagues = new ArrayList<Colleague>();

    public void register(Colleague colleague) {
        if (!colleagues.contains(colleague)) {
            colleagues.add(colleague);
            colleague.setMedium(this);
        }
    }

    public void relay(Colleague cl) {
        for (Colleague ob : colleagues) {
            if (!ob.equals(cl)) {
                ((Colleague) ob).receive();
            }
        }
    }
}

//抽象同事类
abstract class Colleague {
    protected Mediator mediator;

    public void setMedium(Mediator mediator) {
        this.mediator = mediator;
    }

    public abstract void receive();

    public abstract void send();
}

//具体同事类
class ConcreteColleague1 extends Colleague {
    public void receive() {
        System.out.println("具体同事类1收到请求。");
    }

    public void send() {
        System.out.println("具体同事类1发出请求。");
        mediator.relay(this); //请中介者转发
    }
}

//具体同事类
class ConcreteColleague2 extends Colleague {
    public void receive() {
        System.out.println("具体同事类2收到请求。");
    }

    public void send() {
        System.out.println("具体同事类2发出请求。");
        mediator.relay(this); //请中介者转发
    }
}
```



## 19 迭代器模式

> 定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示

**优点**

* 访问一个聚合对象的内容而无须暴露它的内部表示
* 遍历任务交由迭代器完成，这简化了聚合类
* 支持以不同方式遍历一个聚合

**缺点**

* 增加了类的个数



## 20 访问者模式

> 定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式
>
> 例子：电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。

**优点**

* 扩展性好。能够在不改变对象结构中的元素的情况下，为对象结构中的元素添加新的功能
* 复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度
* 灵活性好。将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由的演化而不影响系统的数据结构
* 符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一

**缺点**

* 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”
* 破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性
* 违背了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类

```java
package net.biancheng.c.visitor;

import java.util.*;

public class VisitorPattern {
    public static void main(String[] args) {
        ObjectStructure os = new ObjectStructure();
        os.add(new ConcreteElementA());
        os.add(new ConcreteElementB());
        Visitor visitor = new ConcreteVisitorA();
        os.accept(visitor);
        System.out.println("------------------------");
        visitor = new ConcreteVisitorB();
        os.accept(visitor);
    }
}

//抽象访问者
interface Visitor {
    void visit(ConcreteElementA element);

    void visit(ConcreteElementB element);
}

//具体访问者A类
class ConcreteVisitorA implements Visitor {
    public void visit(ConcreteElementA element) {
        System.out.println("具体访问者A访问-->" + element.operationA());
    }

    public void visit(ConcreteElementB element) {
        System.out.println("具体访问者A访问-->" + element.operationB());
    }
}

//具体访问者B类
class ConcreteVisitorB implements Visitor {
    public void visit(ConcreteElementA element) {
        System.out.println("具体访问者B访问-->" + element.operationA());
    }

    public void visit(ConcreteElementB element) {
        System.out.println("具体访问者B访问-->" + element.operationB());
    }
}

//抽象元素类
interface Element {
    void accept(Visitor visitor);
}

//具体元素A类
class ConcreteElementA implements Element {
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    public String operationA() {
        return "具体元素A的操作。";
    }
}

//具体元素B类
class ConcreteElementB implements Element {
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    public String operationB() {
        return "具体元素B的操作。";
    }
}

//对象结构角色
class ObjectStructure {
    private List<Element> list = new ArrayList<Element>();

    public void accept(Visitor visitor) {
        Iterator<Element> i = list.iterator();
        while (i.hasNext()) {
            ((Element) i.next()).accept(visitor);
        }
    }

    public void add(Element element) {
        list.add(element);
    }

    public void remove(Element element) {
        list.remove(element);
    }
}
```



## 21 备忘录模式

> 定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态，也叫“快照模式”

**优点**

* 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态
* 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能访问这些状态信息
* 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，符合单一职责原则

**缺点**

* 资源消耗打，如果要爆粗你的内部状态信息过多或者特别频繁，将占用比较大的内存资源

```java
package net.biancheng.c.memento;

public class MementoPattern {
    public static void main(String[] args) {
        Originator or = new Originator();
        Caretaker cr = new Caretaker();
        or.setState("S0");
        System.out.println("初始状态:" + or.getState());
        cr.setMemento(or.createMemento()); //保存状态
        or.setState("S1");
        System.out.println("新的状态:" + or.getState());
        or.restoreMemento(cr.getMemento()); //恢复状态
        System.out.println("恢复状态:" + or.getState());
    }
}

//备忘录
class Memento {
    private String state;

    public Memento(String state) {
        this.state = state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }
}

//发起人
class Originator {
    private String state;

    public void setState(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }

    public Memento createMemento() {
        return new Memento(state);
    }

    public void restoreMemento(Memento m) {
        this.setState(m.getState());
    }
}

//管理者
class Caretaker {
    private Memento memento;

    public void setMemento(Memento m) {
        memento = m;
    }

    public Memento getMemento() {
        return memento;
    }
}
```



## 22 解释器模式

> 定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例，这种模式实现了文法表达式处理的接口，改接口解释一个特定的上下文

**优点**

* 扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法
* 容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法比较容易

**缺点**

* 执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦
* 会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护
* 可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用

```java
package net.biancheng.c.interpreter;

//抽象表达式类
interface AbstractExpression {
    public void interpret(String info);    //解释方法
}

//终结符表达式类
class TerminalExpression implements AbstractExpression {
    public void interpret(String info) {
        //对终结符表达式的处理
    }
}

//非终结符表达式类
class NonterminalExpression implements AbstractExpression {
    private AbstractExpression exp1;
    private AbstractExpression exp2;

    public void interpret(String info) {
        //非对终结符表达式的处理
    }
}

//环境类
class Context {
    private AbstractExpression exp;

    public Context() {
        //数据初始化
    }

    public void operation(String info) {
        //调用相关表达式类的解释方法
    }
}
```
