[TOC]

### 1 IOC（原理，使用）

==Spring是一个轻量级的控制反转（IOC）和面向切面编程的框架！==

​		**控制反转（IOC）是一种设计思想，DI（依赖注入）是实现IOC的一种方法**。没有IOC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，认为所谓控制反转就是：**获得依赖对象的方式反转了**

* 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的
* **控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入（Dependency Injection, DI）。**
* **注册组件的四种方式**<img src="../images/image-20210209170027575.png" alt="image-20210209170027575" style="zoom:150%;" />
	
	* `Bean`中可以细分三种方式：构造器、set、拓展方式注入
	
	* **对象创建**
	
		1、从xml配置的Bean,@Bean注解，或者Java代码BeanDefinitionBuilder中读取Bean的定义,实例化Bean对象；
	
		2、设置Bean的属性；
	
		3、注入Aware的依赖（BeanNameAware,BeanFactoryAware,ApplicationContextAware）;
	
		4、执行通用的方法前置处理，方法： BeanPostProcessor.postProcessorBeforeInitialization()
	
		5、执行 InitalizingBean.afterPropertiesSet() 方法
	
		6、执行Bean自定义的初始化方法init,或者 @PostConstruct 标注的方法；
	
		7、执行方法BeanPostProcessor.postProcessorAfterInitialization()
	
		8、创建对象完毕；
	
		**对象销毁**
	
		9、执行 DisposableBean.destory() 方法；
	
		10、执行自定义的destory方法或者 @PreDestory 标注的方法；
	
		11、销毁对象完毕
	
	* **Bean生命周期**
		<img src="../images/image-20210311100218611.png" alt="image-20210311100218611" style="zoom:50%;" />
	
	* `Bean`作用域（单例、原型、Request、Session）：
		
		* 单例模式（默认）：当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，**就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象**。
		* 原型模式：当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。**Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。**



### 2 AOP（原理，为什么提出）

1. AOP（Aspect Oriented Programming）意为：面向切面编程，通过**预编译方式**和**运行期动态代理**实现程序功能统一维护的一种技术。AOP是OOP的延续，是函数式编程的一种衍生笵型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率
	**作用**：==提供声明式事务；允许用户自定义切面==

	* 横切关注点：跨越应用程序多个模块的方法或功能，即是，与业务逻辑无关的，但是需要关注的部分，就是横切关注点。如日志、安全、缓存、事务等等
	* 切面（Aspect）：横切关注点，被模块化的特殊对象。即，是一个类
	* 通知（Advice）：切面必须要完成的工作。即，类中的一个方法
	* 目标（Target）：被通知对象
	* 代理（Proxy）：想目标对象应用通知后创建的对象
	* 切入点（PointCut）：切面通知执行的“地点”的定义
	* 连接点（JointPoint）：与切入点匹配的执行点

2. 五种类型：<img src="../images/image-20201123143645376.png" alt="image-20201123143645376" style="zoom:50%;" />

3. 实现AOP的三种方式

	1. **使用Spring的API接口**（接口，xml中配置）

		```xml
		<!--方式一：使用原生Spring API接口-->
		    <!--配置aop:需要导入AOP的约束-->
		    <aop:config>
		        <!--切入点-->
		        <aop:pointcut id="pointcut" expression="execution(* com.komorebi.service.UserServiceImpl.*(..))"/>
		        <!--执行环绕增强-->
		        <aop:advisor advice-ref="log" pointcut-ref="pointcut"/>
		        <aop:advisor advice-ref="afterLog" pointcut-ref="pointcut"/>
		    </aop:config>
		```

	2. **使用自定义类来实现**（切面，xml中配置）

		```xml
		<!--方式二：自定义类-->
		<bean id="diy" class="com.komorebi.diy.DiyPointCut"/>
		<aop:config>
		    <!--自定义切面，ref要引用的类-->
		    <aop:aspect ref="diy">
		        <!--切入点-->
		        <aop:pointcut id="point" expression="execution(* com.komorebi.service.UserServiceImpl.*(..))"/>
		        <!--通知-->
		        <aop:before method="before" pointcut-ref="point"/>
		        <aop:after method="after" pointcut-ref="point"/>
		    </aop:aspect>
		</aop:config>
		```

	3. **注解**

		```java
		@Aspect     // 标注一个类是切面
		@Before("execution(* com.komorebi.service.UserServiceImpl.*(..))")
		@After("execution(* com.komorebi.service.UserServiceImpl.*(..))")
		@Around("execution(* com.komorebi.service.UserServiceImpl.*(..))")  // around中的before优于Before
		```



### 3 Mybatis流程

MyBatis 是一款优秀的**持久层**框架：

* 内存：**断电即失**
* 数据库(JDBC)：io文件持久化

**Mybatis详细流程**：

![image-20201116100843664](../images/image-20201116100843664.png)

### 4 SpringMVC的常用注解

* `RequestMapping`
* `GetMapping`
* `PostMapping`
* `PathVariable`



### 5 SpringMVC的工作机制

<img src="../images/image-20201125135139804.png" alt="image-20201125135139804" style="zoom:50%;" />



### 6 SpringMVC的底层原理

<img src="../images/image-20201125160106066.png" alt="image-20201125160106066" style="zoom:50%;" />

1. DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求<img src="../images/image-20201125160354276.png" alt="image-20201125160354276" style="zoom:50%;" />
2. HanderMapping为处理器映射。DispatcherServlet调用HanderMapping，HanderMapping根据请求url查找Handler
3. HandlerExecution表示具体Handler。其主要作用是根据url查找控制器，如上url被查找控制器为：hello
4. HandlerExecution将解析后的信息传递给DispatcherServlet，如解析控制器映射等
5. HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler
6. Handler让具体的Controller执行
7. Controller将具体的执行信息返回给HandlerAdapter，如ModelAndView
8. HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet
9. DispatcherServlet调用视图解析器（ViewResolver）来解析HandlerAdapter传递的逻辑视图名
10. 视图解析器将解析的逻辑视图名传给DispatcherServlet
11. DispatcherServlet根据视图解析器解析出的视图结果，调用具体的视图
12. 最终视图呈现给用户



### 7 SpringBoot自动装配

![image-20210302160816782](../images/image-20210302160816782.png)



https://www.cnblogs.com/lzh-boke/p/11876679.html

* `SpringBootConfiguration`:其实就是Spring中的@Configuration，用于标注配置类
* `ComponentScan:`用来将**指定包**下**需要装配的组件**注册到容器中
* `EnableAutoConfiguration`:配置自动装配
	* `AutoConfigurationPackage`:将**主配置类所在的包**作为**自动配置包**进行管理
	* `Import`:导入一个类到IOC容器



### 8 CAP原则

*  RDBMS（Mysql  Oracle  sqlServer） -->  ACID
*  NoSQL （Redis  MongDB） --> CAP 
*  **ACID**：
	* A（Atomicity）：原子性
	* C（Consistency）：一致性
	* I（Isolation）：隔离性
	* D（Durability）：持久性
*  **CAP**：（三进二）
	* C（Consistency）：强一致性
	* A（Availability）：可用性
	* P（Partition tolerance）：分区容错性
	* <img src="../images/image-20210203161037943.png" alt="image-20210203161037943" style="zoom:50%;" />
	* <img src="../images/image-20210203161210970.png" alt="image-20210203161210970" style="zoom: 50%;" />



### 9 @RestController vs @Controller

**Controller返回⼀个⻚⾯**

​		单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要返回⼀个视图的情况，这种情况 属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况。

**@RestController 返回JSON 或 XML 形式数据**

​		 @RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应 (Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况 （前后端分离）

**@Controller +@ResponseBody 返回JSON 或 XML 形式数据**

​		@Controller + @ResponseBody = @RestController

**@ResponseBody**

​		@ResponseBody 注解的作⽤是将Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者 XML 数据，返回 JSON 数据的情况⽐较多。



### 10 @Component 和 @Bean 的区别是什么？

1. **作⽤对象不同**: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。

2. @Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使 ⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到 Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个 bean, @Bean 告诉了Spring这是某个类的示例，当我需要⽤它的时候还给我。

3. @Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注 解来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过 @Bean 来实现。



### 11 Mybatis 是如何进⾏分⻚的？分⻚插件的原理是什么？

​        Mybatis 使⽤ RowBounds 对象进⾏分⻚，它是针对 ResultSet 结果集执⾏的内存分⻚，⽽ ⾮物理分⻚，可以在 sql 内直接书写带有物理分⻚的参数来完成物理分⻚功能，也可以使⽤分⻚ 插件来完成物理分⻚。

​		分⻚插件的基本原理是使⽤ Mybatis 提供的插件接⼝，实现⾃定义插件，在插件的拦截⽅法内拦 截待执⾏的 sql，然后重写 sql，根据 dialect ⽅⾔，添加对应的物理分⻚语句和物理分⻚参数。

