[TOC]

## 电话号码的字母组合（0017）

> *给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。*
>
> *给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。*
>
> *输入："23"*
>
> *输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].*

```java
class Solution {
    private static String[] dict = new String[]{"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};

    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) {
            return new ArrayList<>();
        }

        StringBuilder curSb = new StringBuilder();
        List<String> ans = new ArrayList<>();
        myMethod(digits, ans, curSb, 0);

        return ans;
    }

    private static void myMethod(String digits, List<String> ans, StringBuilder curSb, int idx) {
        if (curSb.length() == digits.length()) {
            ans.add(curSb.toString());
            return;
        }

        String cur = dict[digits.charAt(idx) - '2'];

        for (char c : cur.toCharArray()) {
            curSb.append(c);
            myMethod(digits, ans, curSb, idx + 1);
            curSb.deleteCharAt(curSb.length() - 1);
        }
    }
}
```

## 括号生成（0022）

> *数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。*
>
> *输入：n = 3*
>
> *输出：[*
>
> ​       *"((()))",*
>
> ​       *"(()())",*
>
> ​       *"(())()",*
>
> ​       *"()(())",*
>
> ​       *"()()()"*
>
> ​     *]*

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<>();
        StringBuilder cur = new StringBuilder();
        myMethod(n, ans, cur, 0, 0);
        return ans;
    }

    private static void myMethod(int n, List<String> ans, StringBuilder cur, int start, int end) {
        if (cur.length() == 2 * n) {
            ans.add(cur.toString());
            return;
        }

        if (start < n) {
            cur.append('(');
            myMethod(n, ans, cur, start + 1, end);
            cur.deleteCharAt(cur.length() - 1);
        }

        if (end < start) {
            cur.append(')');
            myMethod(n, ans, cur, start, end + 1);
            cur.deleteCharAt(cur.length() - 1);
        }
    }
}
```

## 组合总数

> 39
>
> *给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。*
>
> *candidates 中的数字可以无限制重复被选取。*

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        myMethod(candidates, target, ans, path, 0, 0);
        
        return ans;
    }

    private static void myMethod(int[] candidates, int target, List<List<Integer>> ans, List<Integer> path, int sum, int begin) {
        if (sum == target) {
            ans.add(new ArrayList<>(path));
            return;
        }

        for (int i = begin; i < candidates.length; i++) {
            int curSum = sum + candidates[i];
            if (curSum <= target) {
                path.add(candidates[i]);
                myMethod(candidates, target, ans, path, curSum, i);
                path.remove(path.size() - 1);
            }
            else {break;}
        }
    }
}
```

> 40
>
> *给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。*
>
> *candidates 中的每个数字在每个组合中只能使用一次。*

```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        myMethod(candidates, target, ans, path, 0, 0);
        
        return ans;
    }

    private static void myMethod(int[] candidates, int target, List<List<Integer>> ans, List<Integer> path, int sum, int begin) {
        if (sum == target) {
            ans.add(new ArrayList<>(path));
            return;
        }

        for (int i = begin; i < candidates.length; i++) {
            // 解集不能包含重复的组合,所以在重复数字时需要跳过
            if (i > begin && candidates[i] == candidates[i - 1]) {continue;}
            int curSum = sum + candidates[i];
            if (curSum <= target) {
                path.add(candidates[i]);
                myMethod(candidates, target, ans, path, curSum, i + 1);
                path.remove(path.size() - 1);
            }
            else {break;}
        }
    }
}
```

> 216
>
> *找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。*

```java
class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        int[] nums = new int[9];
        for (int i = 0; i < 9; i++) {nums[i] = i + 1;}

        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        myMethod(nums, n, k, ans, path, 0, 0);

        return ans;
    }

    private static void myMethod(int[] nums, int n, int k, List<List<Integer>> ans, List<Integer> path, int sum, int begin) {
        if (sum == n && path.size() == k) {
            ans.add(new ArrayList<>(path));
            return;
        }

        for (int i = begin; i < nums.length; i++) {
            int curSum = sum + nums[i];
            if (curSum <= n) {
                path.add(nums[i]);
                myMethod(nums, n, k, ans, path, curSum, i + 1);
                path.remove(path.size() - 1);
            }
            else {break;} 
        }
    }
}
```

> 377
>
> *给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。*

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int i = 1; i <= target; i++) {
            for (int x : nums) {
                if (i >= x) {
                    dp[i] += dp[i - x];
                }
            }
        }
        return dp[target];
    }
}
```

> 77
>
> *给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。*

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {nums[i] = i + 1;}

        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        myMethod(nums, k, ans, path, 0);

        return ans;
    }

    private static void myMethod(int[] nums, int k, List<List<Integer>> ans, List<Integer> path, int begin) {
        if (path.size() == k) {
            ans.add(new ArrayList<>(path));
            return;
        }

        for (int i = begin; i < nums.length; i++) {
            path.add(nums[i]);
            myMethod(nums, k, ans, path, i + 1);
            path.remove(path.size() - 1);
        }
    }
} 
```

## 子集

> 78
>
> *给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。*

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        myMethod(nums, ans, path, 0);
        return ans;
    }

    private static void myMethod(int[] nums, List<List<Integer>> ans, List<Integer> path, int begin) {
        ans.add(new ArrayList<>(path));
        for (int i = begin; i < nums.length; i++) {
            path.add(nums[i]);
            myMethod(nums, ans, path, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

> 90
>
> *给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。*
>
> *说明：解集不能包含重复的子集。*

```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);

        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        myMethod(nums, ans, path, 0);

        return ans;
    }

    private static void myMethod(int[] nums, List<List<Integer>> ans, List<Integer> path, int begin) {
        Collections.sort(path);
        if (!ans.contains(path)) {ans.add(new ArrayList<>(path));}
        for (int i = begin; i < nums.length; i++) {
            path.add(nums[i]);
            myMethod(nums, ans, path, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

## 划分为K个相等的子集（0698）

> *给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。*

```java
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
        int sum = Arrays.stream(nums).sum();
        if (sum % k != 0) {return false;}
        int target = sum / k;
        Arrays.sort(nums);

        int row = nums.length - 1;
        if (nums[row] > target) {return false;}
        while (row >= 0 && nums[row] == target) {		//排除掉nums中与target相同的值。
            row--;
            k--;
        }

        return myMethod(nums, target, new int[k], row);
    }

    private static boolean myMethod(int[] nums, int target, int[] groups, int row) {
        if (row < 0) {return true;}
        int value = nums[row--];						// 取出剩下最大的数。

        for (int i = 0; i < groups.length; i++) {
            if (groups[i] + value <= target) {			// 放入到总和还未大于等于target的group[i]中
                groups[i] += value;    
                if (myMethod(nums, target, groups, row)) {return true;}		// 递归，继续取出一个数
                // 递归结束后，有两种情况：
                // 1. 所有的数都被取出（row为-1返回true）
                // 2. 其中一次返回了false，说明这种放置方法不能满足正好全部放入，则执行以下代码逻辑。
                //group[i]取出这个数，进入下一次循环，放到另一个group[i+1]中。
                groups[i] -= value;

            }
            // 如果group[i]==0，则表示：
            // 该group从未放入过除了 v 以外的其他东西 但是依旧放入失败了，说明 v 无论怎样放置都会失败。
            // 于是，跳出循环返回false
            if (groups[i] == 0) {break;}
        }

        return false;
    }
}
```

## 下一个排列（0031）

> *实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。*
>
> *如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。*
>
> *必须 原地 修改，只允许使用额外常数空间。*
>
> *输入：nums = [1,2,3]*
>
> *输出：[1,3,2]*

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int idx = nums.length - 1;
        while (idx >= 1) {
            if (nums[idx - 1] >= nums[idx]) {
                idx--;
            }
            else {break;}
        }

        if (idx > 0) {
            int left = idx - 1, right = nums.length - 1;
            while (nums[left] >= nums[right]) {right--;}

            int tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
            Arrays.sort(nums, idx, nums.length);
        }
        else {Arrays.sort(nums);}
    }
}
```

## 全排列

> 46
>
> *给定一个 没有重复 数字的序列，返回其所有可能的全排列。*

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        Arrays.sort(nums);

        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        myMethod(nums, ans, path);

        return ans;
    }

    private static void myMethod(int[] nums, List<List<Integer>> ans, List<Integer> path) {
        if (path.size() == nums.length) {
            ans.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (path.contains(nums[i])) {continue;}
            path.add(nums[i]);
            myMethod(nums, ans, path);
            path.remove(path.size() - 1);
        }
    }
}
```

> 47
>
> *给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。*

```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);

        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        boolean[] visited = new boolean[nums.length];
        myMethod(nums, ans, path, visited);

        return ans;
    }

    private static void myMethod(int[] nums, List<List<Integer>> ans, List<Integer> path, boolean[] visited) {
        if (path.size() == nums.length) {
            ans.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) {continue;}

            path.add(nums[i]);
            visited[i] = true;
            myMethod(nums, ans, path, visited);
            visited[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```

## 排列序列（0060）

> *给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。*
>
> *按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：*
>
> *给定 n 和 k，返回第 k 个排列。*

```java
class Solution {
    public String getPermutation(int n, int k) {
        k--;

        int[] count = new int[n];
        count[0] = 1;
        for (int i = 1; i < n; i++) {count[i] = count[i - 1] * i;}

        List<Integer> nums = new ArrayList<>();
        for (int i = 1; i <= n; i++) {nums.add(i);}

        StringBuilder ans = new StringBuilder();
        for (int i = n - 1; i >= 0; i--) {
            int idx = k / count[i];
            ans.append(nums.remove(idx));
            k -= idx * count[i];
        }

        return ans.toString();
    }
}
```

## N皇后（0051 && 0052）

> *n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。*

```java
class Solution {
    List<List<String>> ans = new ArrayList<>();				

    public List<List<String>> solveNQueens(int n) {
        char[][] board = new char[n][n];
        for (char[] i : board){
            Arrays.fill(i, '.');                
        }
        backtrack(board, 0);
        return ans;
    }

    // 路径：board 中小于 row 的那些行都已经成功放置了皇后
    // 选择列表：第 row 行的所有列都是放置皇后的选择
    // 结束条件：row 超过 board 的最后一行
    void backtrack(char[][] board, int row){
        if (row == board.length) {
            ans.add(array2list(board));							
            return;
        }

        for (int col = 0; col < board.length; col++){
            if (!check(board, row, col)){
                continue;
            }
            board[row][col] = 'Q';
            backtrack(board, row + 1);
            board[row][col] = '.';
        }
    }

    List<String> array2list(char[][] board){
        List<String> ans = new ArrayList<>();
        for (char[] i : board){
            StringBuilder s = new StringBuilder();
            for (char j : i){
                s.append(j);
            }
            ans.add(s.toString());
        }
        return ans;
    }

    boolean check(char[][] board, int row, int col){
        int n = board.length;
        // 检查列是否有皇后互相冲突
        for (int i = 0; i < n; i++) {
            if (board[i][col] == 'Q')
                return false;
        }
        // 检查右上方是否有皇后互相冲突
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q')
                return false;
        }
        // 检查左上方是否有皇后互相冲突
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q')
                return false;
        }
        return true;
    }
}
```

> 给你一个整数 n ，返回 n 皇后问题不同的解决方案的数量。

```java
class Solution {
    int res = 0;

    public int totalNQueens(int n) {
        char[][] board = new char[n][n];
        for (char[] i : board) {
            Arrays.fill(i, '.');
        }
        backtrack(board, 0);
        return res;
    }

    public void backtrack(char[][] board, int row) {
        if (row == board.length) {
            res++;
            return;
        }

        for (int col = 0; col < board.length; col++) {
            if (!check(board, row, col)) {continue;}
            board[row][col] = 'Q';
            backtrack(board, row + 1);
            board[row][col] = '.';
        }
    }

    public List<String> array2list(char[][] board) {
        List<String> res = new ArrayList<>();
        for (char[] i : board) {
            StringBuilder s = new StringBuilder();
            for (char j : i) {
                s.append(j);
            }
            res.add(s.toString());
        }
        return res;
    }

    public boolean check(char[][] board, int row, int col) {
        int n = board.length;

        for (int i = 0; i < n; i++) {
            if (board[i][col] == 'Q') {
                return false;
            }
        }

        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q') {
                return false;
            }
        }

        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q')
                return false;
        }
        return true;
    }
}
```

## 单词搜索（0079）

> *给定一个二维网格和一个单词，找出该单词是否存在于网格中。*

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == word.charAt(0)) {
                    if (dfs(board, word, 0, i, j)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    private static boolean dfs(char[][] board, String word, int idx, int row, int col) {
        if (row < 0 || row > board.length - 1 || col < 0 || col > board[0].length - 1) {return false;}
        if (board[row][col] == word.charAt(idx)) {
            board[row][col] = '0';
            idx++;
            if (idx == word.length() || dfs(board, word, idx, row + 1, col) || dfs(board, word, idx, row, col + 1) || dfs(board, word, idx, row - 1, col) || dfs(board, word, idx, row, col - 1)) {
                return true;
            }
            idx--;
            board[row][col] = word.charAt(idx);
        }
        return false;
    }
}
```

## 岛屿数量（0200）

> *给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。*
>
> *岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。*
>
> *此外，你可以假设该网格的四条边均被水包围。*
>
> *输入：grid = [*
>
> *["1","1","1","1","0"],*
>
> *["1","1","0","1","0"],*
>
> *["1","1","0","0","0"],*
>
> *["0","0","0","0","0"]*
>
> *]*
>
> *输出：1*

```java
class Solution {
    public int numIslands(char[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) {return 0;}

        int n = grid.length, m = grid[0].length;
        int ans = 0;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == '1') {
                    ans++;
                    dfs(grid, i, j);
                }
            }
        }

        return ans;
    }

    private static void dfs(char[][] grid, int row, int col) {
        int n = grid.length, m = grid[0].length;

        if (row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == '0') {
            return;
        }

        grid[row][col] = '0';
        dfs(grid, row - 1, col);
        dfs(grid, row + 1, col);
        dfs(grid, row, col + 1);
        dfs(grid, row, col - 1);
    }
}
```

## 累加数（0306）

> *累加数是一个字符串，组成它的数字可以形成累加序列。*
>
> *一个有效的累加序列必须至少包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。*
>
> *给定一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是累加数。*

```java
class Solution {
    public boolean isAdditiveNumber(String num) {
        if (num.length() < 3) {return false;}
        return dfs(num, num.length(), 0, 0, 0, 0);
    }

    /**
     * @param num    原始字符串
     * @param len    原始字符串长度
     * @param idx    当前处理下标
     * @param sum    前面的两个数字之和
     * @param pre    前一个数字
     * @param count  已经生成几个数字
     */
    private static boolean dfs(String num, int len, int idx, long sum, long pre, int count) {
        if (idx == len) {return count > 2;}

        for (int i = idx; i < len; i++) {
            long cur = getCurValue(num, idx, i);
            if (cur < 0 || (count >= 2 && cur != sum)) {continue;}
            if (dfs(num, len, i + 1, pre + cur, cur, count + 1)) {return true;}
        }

        return false;
    }

    private static long getCurValue(String num, int left, int right) {
        if (left < right && num.charAt(left) == '0') {return -1;}
        long ans = 0;
        while (left <= right) {
            ans = ans * 10 + (num.charAt(left++) - '0');
        }
        return ans;
    } 
}
```

## 矩阵中的最长递增路径（0329）

```java
class Solution {
    public int longestIncreasingPath(int[][] matrix) {
        if (matrix.length == 0) {return 0;}
        int n = matrix.length, m = matrix[0].length;
        int[][] visited = new int[n][m];
        int ans = 0;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (visited[i][j] == 0) {
                    ans = Math.max(ans, dfs(matrix, visited, i, j));
                }
            }
        }

        return ans;
    }

    private static int dfs(int[][] matrix, int[][] visited, int row, int col) {
        if (row < 0 || row >= matrix.length || col < 0 || col >= matrix[0].length) {return 0;}
        if (visited[row][col] > 0) {return visited[row][col];}

        int ans = 0;
        if (row - 1 >= 0 && matrix[row - 1][col] > matrix[row][col]) {
            ans = Math.max(ans, dfs(matrix, visited, row - 1, col));
        }
        if (row + 1 < matrix.length && matrix[row + 1][col] > matrix[row][col]) {
            ans = Math.max(ans, dfs(matrix, visited, row + 1, col));
        }
        if (col - 1 >= 0 && matrix[row][col - 1] > matrix[row][col]) {
            ans = Math.max(ans, dfs(matrix, visited, row, col - 1));
        }
        if (col + 1 < matrix[0].length && matrix[row][col + 1] > matrix[row][col]) {
            ans = Math.max(ans, dfs(matrix, visited, row, col + 1));
        }

        visited[row][col] = ans + 1;
        return ans + 1;
    }
}
```

## 复原IP地址

> 给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 `s` 获得的 **有效 IP 地址** 。你可以按任何顺序返回答案。

```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        List<String> ans = new ArrayList<>();
        int[] segment = new int[4];
        dfs(s, ans, segment, 0, 0);
        return ans;
    }

    private static void dfs(String s, List<String> ans, int[] segment, int segId, int segStart) {
        // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
        if (segId == 4) {
            if (segStart == s.length()) {
                StringBuilder ipAddr = new StringBuilder();
                for (int i = 0; i < 4; ++i) {
                    ipAddr.append(segment[i]);
                    if (i != 3) {
                        ipAddr.append('.');
                    }
                }
                ans.add(ipAddr.toString());
            }
            return;
        }

        // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
        if (segStart == s.length()) {return;}

        // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
        if (s.charAt(segStart) == '0') {
            segment[segId] = 0;
            dfs(s, ans, segment, segId + 1, segStart + 1);
        }

        // 一般情况，枚举每一种可能性并递归
        int addr = 0;
        for (int segEnd = segStart; segEnd < s.length(); ++segEnd) {
            addr = addr * 10 + (s.charAt(segEnd) - '0');
            if (addr > 0 && addr <= 0xFF) {
                segment[segId] = addr;
                dfs(s, ans, segment, segId + 1, segEnd + 1);
            } else {
                break;
            }
        }
    }
}
```

## 验证IP地址

> 编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。
>
> 如果是有效的 IPv4 地址，返回 "IPv4" ；
> 如果是有效的 IPv6 地址，返回 "IPv6" ；
> 如果不是上述类型的 IP 地址，返回 "Neither" 。
> IPv4 地址由十进制数和点来表示，每个地址包含 4 个十进制数，其范围为 0 - 255， 用(".")分割。比如，172.16.254.1；
>
> 同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。
>
> IPv6 地址由 8 组 16 进制的数字来表示，每组表示 16 比特。这些组数字通过 (":")分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。

```java
class Solution {
    public String validIPAddress(String IP) {
        if (IP.chars().filter(c -> c == '.').count() == 3) {
            return validateIPv4(IP);
        }
        else if (IP.chars().filter(c -> c == ':').count() == 7) {
            return validateIPv6(IP);
        }
        return "Neither";
    }

    private static String validateIPv4(String IP) {
        String[] nums = IP.split("\\.", -1);
        for (String s : nums) {
            if (s.length() == 0 || s.length() > 3 || (s.charAt(0) == '0' && s.length() != 1)) {return "Neither";}
            for (char c : s.toCharArray()) {
                if (!Character.isDigit(c)) {return "Neither";}
            }
            if (Integer.parseInt(s) > 255) {return "Neither";}
        }
        return "IPv4";
    }

    private static String validateIPv6(String IP) {
        String[] nums = IP.split(":", -1);
        String hexDigits = "0123456789abcdefABCDEF";
        for (String s : nums) {
            if (s.length() == 0 || s.length() > 4) {return "Neither";}
            for (char c : s.toCharArray()) {
                if (hexDigits.indexOf(c) == -1) {return "Neither";}
            }
        }
        return "IPv6";
    }
}
```

## 字典树排数（0386）

> *给定一个整数 n, 返回从 1 到 n 的字典顺序。*
>
> *例如，*
>
> *给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。*

```java
class Solution {
    public List<Integer> lexicalOrder(int n) {
        List<Integer> ans = new ArrayList<>();
        for (int i = 1; i < 10; i++) {
            dfs(n, ans, i);
        }
        return ans;
    }

    private static void dfs(int n, List<Integer> ans, int i) {
        if (i > n) {return;}
        ans.add(i);
        for (int j = 0; j <= 9; j++) {
            dfs(n, ans, i * 10 + j);
        }
    }
}
```

## 二进制手表（0401）

> *二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。*
>
> *每个 LED 代表一个 0 或 1，最低位在右侧。*
>
> 给你一个整数 `turnedOn` ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 **按任意顺序** 返回答案。

```java
class Solution {
    private static int[] dict = new int[]{1, 2, 4, 8, 1, 2, 4, 8, 16, 32};

    public List<String> readBinaryWatch(int turnedOn) {
        List<String> ans = new ArrayList<>();
        dfs(turnedOn, ans, 0, 0, 0);
        return ans;
    }

    private static void dfs(int count, List<String> ans, int hour, int minute, int idx) {
        if (count == 0) {ans.add(hour + ":" + (minute > 9 ? minute : "0" + minute));}

        for (int i = idx; i < 10; i++) {
            if (i < 4 && hour + dict[i] < 12) {
                dfs(count - 1, ans, hour + dict[i], minute, i + 1);
            }
            if (i >= 4 && minute + dict[i] < 60) {
                dfs(count - 1, ans, hour, minute + dict[i], i + 1);
            }
        }
    }
}
```

## 特殊的二进制序列（0761）

> *特殊的二进制序列是具有以下两个性质的二进制序列：*
>
> *0 的数量与 1 的数量相等。*
>
> *二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。*
>
> *给定一个特殊的二进制序列 S，以字符串形式表示。定义一个操作 为首先选择 S 的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)*
>
> *在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？*

```java
// 两个连续的非空特殊子串才可以交换。如对于序列10110100，头部的特殊子串10可以和后面紧接的特殊子串110100交换，但头部的10却不能和110100内部的特殊子串10进行交换(中间隔了一个1)，故原问题可以变成更小的子问题，即对10和110100内部分别进行排序交换，再对两者进行排序交换。
// 对于10，已达字典序排列最大的结果。而对于110100，无法再划分为多个连续的非空特殊子串，此时可以发现，所有特殊二进制序列都满足第一个为1最后一个为0。故取掉首尾的10对中间1010再进行排序交换，最后对字符串多段内部排序交换完成后的子串再进行字典序排序，然后合并在一起，得到最终结果。
class Solution {
    public String makeLargestSpecial(String s) {
        StringBuilder ans = new StringBuilder();
        List<String> subList = new ArrayList<>();

        int start = 0, countOne = 0;
        for (int i = 0; i < s.length(); i++) {
            countOne += (s.charAt(i) == '1' ? 1 : -1);
            if (countOne == 0) {
                String cur = s.substring(start + 1, i);
                subList.add("1" + makeLargestSpecial(cur) + "0");
                start = i + 1;
            }
        }

        Collections.sort(subList);
        for (int i = subList.size() - 1; i >= 0; i--) {
            ans.append(subList.get(i));
        }

        return ans.toString();
    }
}
```

## 最小基因变化（0433）

> *一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 "A", "C", "G", "T"中的任意一个。*
>
> *假设我们要调查一个基因序列的变化。一次基因变化意味着这个基因序列中的一个字符发生了变化。*
>
> *例如，基因序列由"AACCGGTT" 变化至 "AACCGGTA" 即发生了一次基因变化。*
>
> *与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。*
>
> *现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。*

```java
class Solution {
    public int minMutation(String start, String end, String[] bank) {
        Set<String> set = new HashSet<>(Arrays.asList(bank));
        if (!set.contains(end)) {return -1;}
        char[] dict = new char[]{'A', 'C', 'G', 'T'};

        Queue<String> queue = new LinkedList<>();
        queue.offer(start);
        set.remove(start);
        int step = 0;

        while (queue.size() > 0) {
            step++;
            int count = queue.size();
            for (int k = 0; k < count; k++) {
                char[] tmp = queue.poll().toCharArray();
                int n = tmp.length;
                for (int i = 0; i < n; i++) {
                    char oldChar = tmp[i];
                    for (int j = 0; j < 4; j++) {
                        tmp[i] = dict[j];
                        String newGenetic = new String(tmp);
                        if (end.equals(newGenetic)) {
                            return step;
                        }
                        else if (set.contains(newGenetic)) {
                            set.remove(newGenetic);
                            queue.offer(newGenetic);
                        }
                    }
                    tmp[i] = oldChar;
                }
            }
        }

        return -1;
    }
}
```

## 火柴拼正方形（0473）

> 请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。
>
> 输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。

```java
class Solution {
    public boolean makesquare(int[] matchsticks) {
        int sum = Arrays.stream(matchsticks).sum();
        if (sum == 0 || sum % 4 != 0) {return false;}
        return myMethod(matchsticks, sum >> 2, new int[4], 0);
    }

    private static boolean myMethod(int[] nums, int target, int[] edges, int idx) {
        if (idx == nums.length) {
            if (edges[0] == edges[1] && edges[1] == edges[2] && edges[2] == edges[3]) {return true;}
            return false;
        }

        for (int i = 0; i < 4; i++) {
            if (edges[i] + nums[idx] > target) {continue;}

            edges[i] += nums[idx];
            if (myMethod(nums, target, edges, idx + 1)) {return true;}
            edges[i] -= nums[idx];
        }

        return false;
    }
}
```

## 递增子序列（0491）

> *给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2 。*

```java
class Solution {
    public List<List<Integer>> findSubsequences(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        dfs(nums, ans, path, 0, Integer.MIN_VALUE);
        return ans;
    }

    private static void dfs(int[] nums, List<List<Integer>> ans, List<Integer> path, int idx, int pre) {
        if (idx == nums.length) {
            if (path.size() >= 2) {
                ans.add(new ArrayList<>(path));
            }
            return;
        }

        // 使序列合法的办法非常简单，即给「选择当前数」做一个限定条件，只有当前的元素大于等于上一个选择的元素的时候才能选择这个元素，这样枚举出来的所有元素都是合法的
        if (nums[idx] >= pre) {
            path.add(nums[idx]);
            dfs(nums, ans, path, idx + 1, nums[idx]);
            path.remove(path.size() - 1);
        }

        // 那如何保证没有重复呢？我们需要给「不选择当前数」做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。
        if (nums[idx] != pre) {
            dfs(nums, ans, path, idx + 1, pre);
        }
    }
}
```

## 优美的排列

> 526
>
> 假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：
>
> 第 i 位的数字能被 i 整除
> i 能被第 i 位上的数字整除
> 现在给定一个整数 N，请问可以构造多少个优美的排列？

```java
class Solution {
    public int countArrangement(int n) {
        int[] count = new int[1];
        boolean[] visited = new boolean[n + 1];
        backtrack(n, count, visited, 1);
        return count[0];
    }

    private void backtrack(int n, int[] count, boolean[] visited, int pos) {
        if (pos > n) {count[0]++;}

        for (int i = 1; i <= n; i++) {
            if (!visited[i] && (pos % i == 0 || i % pos == 0)) {
                visited[i] = true;
                backtrack(n, count, visited, pos + 1);
                visited[i] = false;
            }
        }
    }
}
```

> 667
>
> *给定两个整数 n 和 k，你需要实现一个数组，这个数组包含从 1 到 n 的 n 个不同整数，同时满足以下条件：*
>
> *① 如果这个数组是 [a1, a2, a3, ... , an] ，那么数组 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数；.*
>
> *② 如果存在多种答案，你只需实现并返回其中任意一种.*

```java
class Solution {
    public int[] constructArray(int n, int k) {
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {ans[i] = i + 1;}
        if (k == 1) {return ans;}

        for (int i = 1; i < k; i++) {myReverse(ans, i, n - 1);}

        return ans;
    }

    // 找规律构造
    private static void myReverse(int[] ans, int i, int j) {
        while (i < j) {
            int tmp = ans[i];
            ans[i] = ans[j];
            ans[j] = tmp;
            i++;
            j--;
        }
    }
}
```

## 奇怪的打印机

> 664
>
> *有台奇怪的打印机有以下两个特殊要求：*
>
> *打印机每次只能打印同一个字符序列。*
>
> *每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。*
>
> *给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。*

```java
class Solution {
    int[][] memo;

    public int strangePrinter(String s) {
        int n = s.length();
        memo = new int[n][n];
        return myMethod(s, 0, n - 1);
    }

    private int myMethod(String s, int i, int j) {
        if (i > j) {return 0;}
        if (memo[i][j] == 0) {
            int ans = myMethod(s, i + 1, j) + 1;
            for (int k = i + 1; k <= j; k++) {
                if (s.charAt(k) == s.charAt(i)) {
                    ans = Math.min(ans, myMethod(s, i, k - 1) + myMethod(s, k + 1, j));
                }
            }
            memo[i][j] = ans;
        }
        return memo[i][j];
    }
}
```

## 钥匙和房间（0841）

> *有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。*
>
> *在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。*
>
> *最初，除 0 号房间外的其余所有房间都被锁住。*
>
> *你可以自由地在房间之间来回走动。*
>
> *如果能进入每个房间返回 true，否则返回 false。*

```java
// DFS
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        int[] count = new int[1];
        boolean[] visited = new boolean[n];

        dfs(rooms, count, visited, 0);

        return count[0] == n;
    }
    
    private static void dfs(List<List<Integer>> rooms, int[] count, boolean[] visited, int idx) {
        visited[idx] = true;
        count[0]++;
        for (int neigh : rooms.get(idx)) {
            if (!visited[neigh]) {
                dfs(rooms, count, visited, neigh);
            }
        }
    }
}

// BFS
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        int count = 0;
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();

        queue.offer(0);
        visited[0] = true;
        while (!queue.isEmpty()) {
            int cur = queue.poll();
            count++;
            for (int neigh : rooms.get(cur)) {
                if (!visited[neigh]) {
                    queue.offer(neigh);
                    visited[neigh] = true;
                }
            }
        }

        return count == n;
    }
}
```

## 大礼包（0638）

> *商店中， 有许多在售的物品。*
>
> *然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。*
>
> *现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。*
>
> *每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。*
>
> *任意大礼包可无限次购买。*

```java
class Solution {
    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {
        Map<List<Integer>, Integer> map = new HashMap<>();
        return dfs(price, special, needs, map);
    }

    private static int dfs(List<Integer> price, List<List<Integer>> special, List<Integer> needs, Map<List<Integer>, Integer> map) {
        if (map.containsKey(needs)) {return map.get(needs);}

        // 初始化ans为不买礼包的情况
        int ans = 0;
        for (int i = 0; i < needs.size(); i++) {
            ans += needs.get(i) * price.get(i);
        }

        // needs[i, j] = needs[i - m, j - n] + vals[m, n]  
        for (List<Integer> s : special) {
            List<Integer> clone = new ArrayList<>(needs);
            int i;
            for (i = 0; i < needs.size(); i++) {
                int diff = clone.get(i) - s.get(i);
                if (diff < 0) {break;}
                clone.set(i, diff);
            }
            if (i == needs.size()) {
                ans = Math.min(ans, s.get(i) + dfs(price, special, clone, map));
            }
        }

        map.put(needs, ans);
        return ans;
    }
}
```

## 图像渲染（0733）

> *有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。*
>
> *给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。*
>
> *为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。*
>
> *最后返回经过上色渲染后的图像。*

```java
// BFS
class Solution {
    private static int[] dx = new int[]{1, 0, 0, -1};
    private static int[] dy = new int[]{0, 1, -1, 0};

    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int curColor = image[sr][sc];
        if (curColor == newColor) {return image;}

        int n = image.length, m = image[0].length;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{sr, sc});
        image[sr][sc] = newColor;

        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int x = cur[0], y = cur[1];
            for (int i = 0; i < 4; i++) {
                int nextX = x + dx[i], nextY = y + dy[i];
                if (nextX >= 0 && nextX < n && nextY >= 0 && nextY < m && image[nextX][nextY] == curColor) {
                    queue.offer(new int[]{nextX, nextY});
                    image[nextX][nextY] = newColor;
                }
            }
        }

        return image;
    }
}

// DFS
class Solution {
    private static int[] dx = new int[]{1, 0, 0, -1};
    private static int[] dy = new int[]{0, 1, -1, 0};

    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int curColor = image[sr][sc];
        if (curColor != newColor) {
            dfs(image, sr, sc, newColor, curColor);
        }
        return image;
    }

    private static void dfs(int[][] image, int x, int y, int newColor, int curColor) {
        int n = image.length, m = image[0].length;

        if (image[x][y] == curColor) {
            image[x][y] = newColor;
            for (int i = 0; i < 4; i++) {
                int nextX = x + dx[i], nextY = y + dy[i];
                if (nextX >= 0 && nextX < n && nextY >= 0 && nextY < m) {
                    dfs(image, nextX, nextY, newColor, curColor);
                }
            }
        }
    }
}
```

## 达到终点（0780）

> *从点 (x, y) 可以转换到 (x, x+y) 或者 (x+y, y)。*
>
> *给定一个起点 (sx, sy) 和一个终点 (tx, ty)，如果通过一系列的转换可以从起点到达终点，则返回 True ，否则返回 False。*

```java
// 回溯
class Solution {
    public boolean reachingPoints(int sx, int sy, int tx, int ty) {
        while (tx >= sx && ty >= sy) {
            if (tx == ty) {break;}
            if (tx > ty) {
                if (ty > sy) {tx %= ty;}
                else {return (tx - sx) % ty == 0;}
            }
            else {
                if (tx > sx) {ty %= tx;}
                else {return (ty - sy) % tx == 0;}
            }
        }
        return (tx == sx && ty == sy);
    }
}
```

## 金字塔转换矩阵（0756）

> *现在，我们用一些方块来堆砌一个金字塔。 每个方块用仅包含一个字母的字符串表示。*
>
> *使用三元组表示金字塔的堆砌规则如下：*
>
> *对于三元组 ABC ，C 为顶层方块，方块 A 、B 分别作为方块 C 下一层的的左、右子块。当且仅当 ABC 是被允许的三元组，我们才可以将其堆砌上。*
>
> *初始时，给定金字塔的基层 bottom，用一个字符串表示。一个允许的三元组列表 allowed，每个三元组用一个长度为 3 的字符串表示。*
>
> *如果可以由基层一直堆到塔尖就返回 true ，否则返回 false 。*

```java
class Solution {
    int[][] T;
    Set<Long> seen;

    public boolean pyramidTransition(String bottom, List<String> allowed) {
        T = new int[7][7];
        for (String a: allowed)
            T[a.charAt(0) - 'A'][a.charAt(1) - 'A'] |= 1 << (a.charAt(2) - 'A');

        seen = new HashSet();
        int N = bottom.length();
        int[][] A = new int[N][N];
        int t = 0;
        for (char c: bottom.toCharArray())
            A[N-1][t++] = c - 'A';
        return solve(A, 0, N-1, 0);
    }

    //A[i] - the ith row of the pyramid
    //R - integer representing the current row of the pyramid
    //N - length of current row we are calculating
    //i - index of how far in the current row we are calculating
    //Returns true iff pyramid can be built
    public boolean solve(int[][] A, long R, int N, int i) {
        if (N == 1 && i == 1) { // If successfully placed entire pyramid
            return true;
        } else if (i == N) {
            if (seen.contains(R)) return false; // If we've already tried this row, give up
            seen.add(R); // Add row to cache
            return solve(A, 0, N-1, 0); // Calculate next row
        } else {
            // w's jth bit is true iff block #j could be
            // a parent of A[N][i] and A[N][i+1]
            int w = T[A[N][i]][A[N][i+1]];
            // for each set bit in w...
            for (int b = 0; b < 7; ++b) if (((w >> b) & 1) != 0) {
                A[N-1][i] = b; //set parent to be equal to block #b
                //If rest of pyramid can be built, return true
                //R represents current row, now with ith bit set to b+1
                // in base 8.
                if (solve(A, R * 8 + (b+1), N, i+1)) return true;
            }
            return false;
        }
    }
}
```

## 破解保险箱（0753）

> *有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。*
>
> *你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。*
>
> *举个例子，假设密码是 "345"，你可以输入 "012345" 来打开它，只是你输入了 6 个字符.*
>
> *请返回一个能打开保险箱的最短字符串。*

```java
class Solution {
    Set<Integer> visited = new HashSet<>();
    StringBuffer ans = new StringBuffer();
    int highest;
    int k;

    public String crackSafe(int n, int k) {
        highest = (int)Math.pow(10, n - 1);
        this.k = k;
        dfs(0);
        for (int i = 1; i < n; i++) {ans.append('0');}
        return ans.toString();
    }

    private void dfs(int node) {
        for (int x = 0; x < k; x++) {
            int neigh = node * 10 + x;
            if (!visited.contains(neigh)) {
                visited.add(neigh);
                dfs(neigh % highest);
                ans.append(x);
            }
        }
    }
}
```

## 为高尔夫比赛砍树（0675）

> *你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 m x n 的矩阵表示， 在这个矩阵中：*
>
> *0 表示障碍，无法触碰*
>
> *1 表示地面，可以行走*
>
> *比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度*
>
> *每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。*
>
> *你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 1（即变为地面）。*
>
> *你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。*
>
> *可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。*

```java
class Solution {
    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    public int cutOffTree(List<List<Integer>> forest) {
        if (forest.size() == 0 || forest.get(0).size() == 0) {return 0;}

        int n = forest.size(), m = forest.get(0).size();
        PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a, b) -> a[2] - b[2]);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(forest.get(i).get(j) > 1){   
                    minHeap.add(new int[]{i, j, forest.get(i).get(j)});
                }
            }
        }

        int[] start = new int[2];
        int ans = 0;
        while (!minHeap.isEmpty()) {
            int[] lowest = minHeap.poll();
            int step = minStep(forest, start, lowest);
            if (step < 0) {return -1;}

            ans += step;
            start[0] = lowest[0];
            start[1] = lowest[1];
        }

        return ans;
    }

    private int minStep(List<List<Integer>> forest, int[] start, int[] lowest) {
        int n = forest.size(), m = forest.get(0).size();
        int step = 0;

        LinkedList<int[]> queue = new LinkedList<>();
        boolean[][] visited = new boolean[n][m];

        queue.add(start);
        visited[start[0]][start[1]] = true;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] cur = queue.poll();
                if (cur[0] == lowest[0] && cur[1] == lowest[1]) {return step;}

                for (int[] dir : dirs) {
                    int nextX = cur[0] + dir[0];
                    int nextY = cur[1] + dir[1];
                    if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= m || visited[nextX][nextY] || forest.get(nextX).get(nextY) == 0) {continue;}

                    queue.add(new int[]{nextX, nextY});
                    visited[nextX][nextY] = true;
                }
            }
            step++;
        }

        return -1;
    }
}
```

