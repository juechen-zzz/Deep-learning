[TOC]

# 回文

## 最长回文串

> 409
>
> *给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。*
>
> *在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。*

```java
class Solution {
    public int longestPalindrome(String s) {
        if (s.length() == 0) {return 0;}
        Map<Character, Integer> count = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            count.put(c, count.getOrDefault(c, 0) + 1);
        }

        int ans = 0;
        boolean single = true;
        for (char c : count.keySet()) {
            // 当第一次出现字符为奇数个，可以全部加上，但只能加一次，后续就必须成对
            if (single && count.get(c) % 2 == 1) {
                ans += count.get(c);
                single = false;
            }
            else {
                if (count.get(c) % 2 == 0) {
                    ans += count.get(c);
                }
                else {
                    ans += count.get(c) - 1;
                }
            }
        }

        return ans;
    }
}
```

## 验证回文串

> 125
>
> *给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。*

```java
class Solution {
    public boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        while (left < right) {
            // 只考虑字母和数字字符回文,所以用isLetterOrDigit
            if (!Character.isLetterOrDigit(s.charAt(left))) {left++;}
            else if (!Character.isLetterOrDigit(s.charAt(right))) {right--;}
            else {
                if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {return false;}
                left++;
                right--;
            }
        }
        return true;
    }
}
```

> 680
>
> *给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。*

```java
class Solution {
    public boolean validPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        while (left < right) {
            char c1 = s.charAt(left), c2 = s.charAt(right);
            if (c1 == c2) {
                left++;
                right--;
            }
            else {
                return backtracking(s, left, right - 1) || backtracking(s, left + 1, right);
            }
        }
        return true;
    }

    private static boolean backtracking(String s, int left, int right) {
        for (int i = left, j = right; i < j; i++, j--) {
            char c1 = s.charAt(i), c2 = s.charAt(j);
            if (c1 != c2) {return false;}
        }
        return true;
    }
}
```

## 分割回文串

> 131
>
> *给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。*
>
> *返回 s 所有可能的分割方案。*

```java
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> ans = new ArrayList<>();
        int n = s.length();
        if (n == 0) {return ans;}
        Deque<String> path = new LinkedList<>();

        myMethod(s, n, ans, path, 0);
        return ans;
    }

    private static void myMethod(String s, int len, List<List<String>> ans, Deque<String> path, int begin) {
        if (begin == len) {
            ans.add(new ArrayList<>(path));
            return;
        }

        for (int i = begin; i < len; i++) {
            if (!check(s, begin, i)) {continue;}
            path.offerLast(s.substring(begin, i + 1));
            myMethod(s, len, ans, path, i + 1);
            path.pollLast();
        }
    }

    private static boolean check(String s, int left, int right) {
        for (int i = left, j = right; i < j; i++, j--) {
            char c1 = s.charAt(i), c2 = s.charAt(j);
            if (c1 != c2) {return false;}
        }
        return true;
    }
}
```

> 132
>
> *给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。*
>
> *返回符合要求的最少分割次数。*

```java
class Solution {
    public int minCut(String s) {
        int n = s.length();
        if (n < 2) {return 0;}

        int[] dp = new int[n];
        for (int i = 0; i < n; i++) {dp[i] = i;}

        for (int i = 1; i < n; i++) {
            if (check(s, 0, i)) {
                dp[i] = 0;
                continue;
            }

            for (int j = 0; j < i; j++) {
                if (check(s, j + 1, i)) {
                    dp[i] = Math.min(dp[i], dp[j] + 1);
                }
            }
        }

        return dp[n - 1];
    }

    private static boolean check(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {return false;}
            left++;
            right--;
        }
        return true;
    }
}
```

## 回文子串

> 647
>
> *给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。*
>
> *具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。*

```java
class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int ans = 0;

        for (int j = 0; j < n; j++) {
            for (int i = 0; i <= j; i++) {
                //如果i和j指向的字符不一样，那么dp[i][j]就不能构成回文字符串
                if (s.charAt(i) != s.charAt(j)) {continue;}
                dp[i][j] = (j - i <= 2 || dp[i + 1][j - 1]);
                //如果从i到j能构成回文串，count就加1
                if (dp[i][j]) {ans++;}
            }
        }

        return ans;()
    }
}
```

# 滑动窗口

## 无重复字符的最长子串

> 3
>
> *给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。*
>
> *输入: s = "abcabcbb"*
>
> *输出: 3* 
>
> *解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。*

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> count = new HashMap<>();
        int left = 0, right = 0;
        int ans = 0;

        while (right < s.length()) {
            char cur = s.charAt(right);
            count.put(cur, count.getOrDefault(cur, 0) + 1);
            right++;

            while (count.get(cur) == 2) {
                char del = s.charAt(left);
                count.put(del, count.get(del) - 1);
                left++;
            }

            ans = Math.max(ans, right - left);
        }

        return ans;
    }
}
```

## 串联所有单词的子串

> 30
>
> *给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。*
>
> *注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。*
>
> *输入：*
>
> *s = "barfoothefoobarman",*
>
> *words = ["foo","bar"]*
>
> *输出：[0,9]*
>
> *解释：*
>
> *从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。*
>
> *输出的顺序不重要, [9,0] 也是有效答案。*

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> ans = new ArrayList<>();
        if (s.length() == 0 || words.length == 0) {
            return ans;
        }

        int oneLen = words[0].length(), n = words.length;
        int targetLen = oneLen * n;
        Map<String, Integer> map = new HashMap<>();
        for (String cur : words) {
            map.put(cur, map.getOrDefault(cur, 0) + 1);
        }

        for (int i = 0; i < s.length() - targetLen + 1; i++) {
            String cur = s.substring(i, i + targetLen);
            Map<String, Integer> tmp = new HashMap<>();
            for (int j = 0; j < targetLen; j += oneLen) {
                String tmpWord = cur.substring(j, j + oneLen);
                tmp.put(tmpWord, tmp.getOrDefault(tmpWord, 0) + 1);
            }

            if (tmp.equals(map)) {
                ans.add(i);
            }
        }

        return ans;
    }
}
```

## 最小覆盖子串

> 76
>
> *给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。*
>
> *注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。*

```java
class Solution {
    public String minWindow(String s, String t) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            char c = t.charAt(i);
            need.put(c, need.getOrDefault(c, 0) + 1);
        }

        int left = 0, right = 0;
        int valid = 0;
        int start = 0, len = s.length() + 1;
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c) - need.get(c) == 0) {valid++;}
            }

            while (valid == need.size()) {
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                char d = s.charAt(left);
                left++;
                if (need.containsKey(d)) {
                    if (window.get(d) - need.get(d) == 0) {valid--;}
                    window.put(d, window.get(d) - 1);
                }
            }
        }

        return len == s.length() + 1 ? "" : s.substring(start, start + len);
    }
}
```

## 至少有K个重复字符的最长子串

> 395
>
> *给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。*

```java
class Solution {
    public int longestSubstring(String s, int k) {
        int ans = 0;
        int n = s.length();

        // total:窗口内的字符种类数目 less:窗口中还有几种字符未达到k次
        for (int i = 0; i <= 26; i++) {
            int left = 0, right = 0;
            int[] count = new int[26];
            int total = 0, less = 0;

            while (right < n) {
                count[s.charAt(right) - 'a']++;
                if (count[s.charAt(right) - 'a'] == 1) {
                    total++;
                    less++;
                }
                if (count[s.charAt(right) - 'a'] == k) {
                    less--;
                }

                while (total > i) {
                    count[s.charAt(left) - 'a']--;
                    if (count[s.charAt(left) - 'a'] == k - 1) {less++;}
                    if (count[s.charAt(left) - 'a'] == 0) {
                        total--;
                        less--;
                    }
                    left++;
                }

                if (less == 0) {ans = Math.max(ans, right - left + 1);}
                right++;
            }
        }

        return ans;
    }
}
```

## 替换后的最长重复字符

> 424
>
> *给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。*
>
> *注意：字符串长度 和 k 不会超过 104。*

```java
class Solution {
    public int characterReplacement(String s, int k) {
        int n = s.length();
        if (n < 2) {return n;}

        char[] charArray = s.toCharArray();
        int left = 0, right = 0;
        int ans = 0, maxCount = 0;
        int[] count = new int[26];

        while (right < n) {
            count[charArray[right] - 'A']++;
            maxCount = Math.max(maxCount, count[charArray[right] - 'A']);
            right++;

            if (right - left > maxCount + k) {
                count[charArray[left] - 'A']--;
                left++;
            }

            ans = Math.max(ans, right - left);
        }

        return ans;
    }
}
```

## 找到字符串中所有字母异位词

> 438
>
> *给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。*
>
> *字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。*

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        for (int i = 0; i < p.length(); i++) {
            char c = p.charAt(i);
            need.put(c, need.getOrDefault(c, 0) + 1);
        }

        int left = 0, right = 0;
        int valid = 0;
        List<Integer> ans = new ArrayList<>();

        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c) - need.get(c) == 0) {valid++;}
            }

            while (right - left >= p.length()) {
                if (valid - need.size() == 0) {ans.add(left);}
                char d = s.charAt(left);
                left++;
                if (need.containsKey(d)) {
                    if (window.get(d) - need.get(d) == 0) {valid--;}
                    window.put(d, window.get(d) - 1);
                }
            }
        }

        return ans;
    }
}
```

## 字符串的排列

> 567
>
> *给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。*
>
> *换句话说，第一个字符串的排列之一是第二个字符串的子串。*

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        for (int i = 0; i < s1.length(); i++) {
            char c = s1.charAt(i);
            need.put(c, need.getOrDefault(c, 0) + 1);
        }

        int left = 0, right = 0;
        int valid = 0;
    
        while (right < s2.length()) {
            char c = s2.charAt(right);
            right++;
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c) - need.get(c) == 0) {valid++;}
            }

            while (right - left >= s1.length()) {
                if (valid == need.size()) {return true;}
                char d = s2.charAt(left);
                left++;
                if (need.containsKey(d)) {
                    if (window.get(d) - need.get(d) == 0) {valid--;}
                    window.put(d, window.get(d) - 1);
                }
            }
        }

        return false;
    }
}
```

# 其他

## 删除无效的括号

> 301
>
> *删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。*
>
> *说明: 输入可能包含了除 ( 和 ) 以外的字符。*

```java
class Solution {
    public List<String> removeInvalidParentheses(String s) {
        Set<String> set = new HashSet<>();
        List<String> ans = new ArrayList<>();
        set.add(s);
        
        while (true) {
            for (String cur : set) {
                if (myMethod(cur)) {ans.add(cur);}
            }
            if (ans.size() > 0) {return ans;}
            
            Set<String> nextSet = new HashSet<>();
            for (String cur : set) {
                for (int i = 0; i < cur.length(); i++) {
                    if (cur.charAt(i) == '(' || cur.charAt(i) == ')') {
                        nextSet.add(cur.substring(0, i) + cur.substring(i + 1, cur.length()));
                    }
                }
            }
            set = nextSet;
        }
    }

    private static boolean myMethod(String s) {
        char[] charArray = s.toCharArray();
        int count = 0;
        for (char c : charArray) {
            if (c == '(') {count++;}
            else if (c == ')') {count--;}
            if (count < 0) {return false;}
        }
        return count == 0;
    }
}
```

## 字母异位词分组

> 49
>
> *给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。*

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        for (String s : strs) {
            char[] cur = s.toCharArray();
            Arrays.sort(cur);
            String key = new String(cur);

            List<String> curList = map.getOrDefault(key, new ArrayList<String>());
            curList.add(s);
            map.put(key, curList);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```

## 二进制求和

> 67
>
> *给两个二进制字符串，返回它们的和（用二进制表示）。*
>
> *输入为 非空 字符串且只包含数字 1 和 0。*

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder ans = new StringBuilder();
        int curSum = 0;
        for (int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0; i--, j--) {
            int sum = curSum;
            sum += (i >= 0 ? a.charAt(i) - '0' : 0);
            sum += (j >= 0 ? b.charAt(j) - '0' : 0);
            ans.append(sum % 2);
            curSum = sum / 2;
        }
        ans.append((curSum == 1 ? curSum : ""));
        return ans.reverse().toString();
    }
}
```

## 单词拆分

> 139
>
> *给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。*

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length();
        if (n == 0) {return true;}

        boolean[] dp = new boolean[n + 1];
        dp[0] = true;

        for (int i = 0; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDict.contains(s.substring(j, i))) {
                    dp[i] = true;
                }
            }
        }

        return dp[n];
    }
}
```

> 140
>
> *给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。*

```java
class Solution {
    public List<String> wordBreak(String s, List<String> wordDict) {
        int n = s.length();

        // 第 1 步：动态规划得到是否可以划分
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDict.contains(s.substring(j, i))) {
                    dp[i] = true;
                }
            }
        }

        // 第 2 步：回溯算法搜索所有符合条件的解
        List<String> ans = new ArrayList<>();
        if (dp[n]) {
            Deque<String> deque = new LinkedList<>();
            dfs(s, n, wordDict, dp, deque, ans);
            return ans;
        }

        return ans;
    }

    private static void dfs(String s, int len, List<String> wordDict, boolean[] dp, Deque<String> deque, List<String> ans) {
        if (len == 0) {
            ans.add(String.join(" ", deque));
            return;
        }

        for (int i = len - 1; i >= 0; i--) {
            String tmp = s.substring(i, len);
            if (dp[i] && wordDict.contains(tmp)) {
                deque.offerFirst(tmp);
                dfs(s, i, wordDict, dp, deque, ans);
                deque.pollFirst();
            }
        }
    }
}
```

## 翻转字符串中的单词

> 151
>
> *给定一个字符串，逐个翻转字符串中的每个单词。*
>
> *示例 1：*
>
> *输入："the sky is blue"*
>
> *输出："blue is sky the"*

```java
class Solution {
    public String reverseWords(String s) {
        // 除去开头和末尾的空白字符
        s = s.trim();
        // 正则匹配连续的空白字符作为分隔符分割
        List<String> wordList = Arrays.asList(s.split("\\s+"));
        Collections.reverse(wordList);
        return String.join(" ", wordList);
    }
}
```

## 重构字符串

> 767
>
> *给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。*
>
> *若可行，输出任意可行的结果。若不可行，返回空字符串。*

```java
class Solution {
    public String reorganizeString(String s) {
        int n = s.length();
        int[] count = new int[26];
        for (int i = 0; i < n; i++) {count[s.charAt(i) - 'a']++;}

        int maxCount = 0, alphabet = 0;
        for (int i = 0; i < 26; i++) {
            if (count[i] > maxCount) {
                maxCount = count[i];
                alphabet = i;
                if (maxCount > (n + 1) / 2) {return "";}
            }
        }

        char[] ans = new char[n];
        int idx = 0;
        while (count[alphabet] > 0) {
            ans[idx] = (char)(alphabet + 'a');
            idx += 2;
            count[alphabet]--;
        }

        for (int i = 0; i < 26; i++) {
            while (count[i] > 0) {
                if (idx >= n) {idx = 1;}
                ans[idx] = (char)(i + 'a');
                idx += 2;
                count[i]--;
            }
        }

        return new String(ans);
    }
}
```

## 反转字符串

> 541
>
> *给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。*
>
> *如果剩余字符少于 k 个，则将剩余字符全部反转。*
>
> *如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。*

```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] ans = s.toCharArray();
        for (int i = 0; i < ans.length; i += 2 * k) {
            int left = i, right = Math.min(i + k - 1, ans.length - 1);
            while (left < right) {
                char tmp = ans[left];
                ans[left++] = ans[right];
                ans[right--] = tmp;
            }
        }
        return new String(ans);
    }
}
```

## 比较版本号

> 165
>
> *给你两个版本号 version1 和 version2 ，请你比较它们。*

```java
class Solution {
    public int compareVersion(String version1, String version2) {
        String[] nums1 = version1.split("\\.");
        String[] nums2 = version2.split("\\.");
        int n1 = nums1.length, n2 = nums2.length;

        int cur1, cur2;
        for (int i = 0; i < Math.max(n1, n2); i++) {
            cur1 = i < n1 ? Integer.parseInt(nums1[i]) : 0;
            cur2 = i < n2 ? Integer.parseInt(nums2[i]) : 0;
            if (cur1 != cur2) {return cur1 > cur2 ? 1 : -1;}
        }

        return 0;
    }
}
```

## 最大数

> 179
>
> *给定一组非负整数 nums，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。*

```java
class Solution {
    public String largestNumber(int[] nums) {
        String[] strs = new String[nums.length];
        for (int i = 0; i < nums.length; i++) {
            strs[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(strs, (o1, o2) -> (o2 + o1).compareTo(o1 + o2));

        StringBuilder ans = new StringBuilder();
        for (String s : strs) {
            if (ans.toString().equals("0")) {ans.delete(0, 1);}
            ans.append(s);
        }

        return ans.toString();
    }
}
```

## 移掉K位数字

> 402
>
> 给定一个以字符串表示的非负整数 *num*，移除这个数中的 *k* 位数字，使得剩下的数字最小。

```java
class Solution {
    public String removeKdigits(String num, int k) {
        Deque<Character> deque = new LinkedList<>();
        for (int i = 0; i < num.length(); i++) {
            char c = num.charAt(i);
            while (!deque.isEmpty() && k > 0 && deque.peekLast() > c) {
                deque.pollLast();
                k--;
            }
            deque.offerLast(c);
        }

        for (int i = 0; i < k; i++) {deque.pollLast();}

        StringBuilder ans = new StringBuilder();
        boolean leadingZero = true;
        while (!deque.isEmpty()) {
            char curNum = deque.pollFirst();
            if (leadingZero && curNum == '0') {continue;}
            leadingZero = false;
            ans.append(curNum);
        }

        return ans.length() == 0 ? "0" : ans.toString();
    }
}
```

## 最大单词长度乘积

> 318
>
> *给定一个字符串数组 words，找到 length(word[i]) \* length(word[j]) 的最大值，并且这两个单词不含有公共字母。*
>
> *可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。*

```java
class Solution {
    public int maxProduct(String[] words) {
        int n = words.length;
        int[] wordToNum = new int[n];
        for (int i = 0; i < n; i++) {
            String cur = words[i];
            int num = 0;
            for (int j = 0; j < cur.length(); j++) {
                int idx = cur.charAt(j) - 'a';
                num = num | (1 << idx);
            }
            wordToNum[i] = num;
        }

        int ans = 0;
        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                if ((wordToNum[i] & wordToNum[j]) != 0) {continue;}
                ans = Math.max(ans, words[i].length() * words[j].length());
            }
        }

        return ans;
    }
}
```

## 同构字符串

> 205
>
> *给定两个字符串 s 和 t，判断它们是否是同构的。*
>
> *如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。*
>
> *所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。*

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> s2t = new HashMap<>();
        Map<Character, Character> t2s = new HashMap<>();
        int n = s.length();
        for (int i = 0; i < n; i++) {
            char x = s.charAt(i), y = t.charAt(i);
            if ((s2t.containsKey(x) && s2t.get(x) != y) || (t2s.containsKey(y) && t2s.get(y) != x)) {return false;}
            
            s2t.put(x, y);
            t2s.put(y, x);
        }
        return true;
    }
}
```

## 去除重复字母

> 316
>
> *给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。*
>
> *需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。*

```java
class Solution {
    public String removeDuplicateLetters(String s) {
        Stack<Character> stack = new Stack<>();
        int[] count = new int[26];
        boolean[] exists = new boolean[26];
        for (char c : s.toCharArray()) {count[c - 'a']++;}

        for (int i = 0; i < s.length(); i++) {
            char cur = s.charAt(i);
            if (!exists[cur - 'a']) {
                while (!stack.isEmpty() && stack.peek() > cur && count[stack.peek() - 'a'] > 0) {
                    exists[stack.peek() - 'a'] = false;
                    stack.pop();
                }
                exists[cur - 'a'] = true;
                stack.push(cur);
            }
            count[cur - 'a']--;
        }

        StringBuilder ans = new StringBuilder();
        for (char c : stack) {ans.append(c);}
        return ans.toString();
    }
}
```

## 字符串解码

> 394
>
> *给定一个经过编码的字符串，返回它解码后的字符串。*
>
> *编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。*
>
> 输入：s = "3[a]2[bc]"
> 输出："aaabcbc"

```java
class Solution {
    public String decodeString(String s) {
        Stack<Integer> count = new Stack<>();
        Stack<StringBuilder> preStr = new Stack<>();
        StringBuilder ans = new StringBuilder();

        int num = 0;
        for (char c : s.toCharArray()) {
            if (Character.isDigit(c)) {num = num * 10 + (c - '0');}
            else if (Character.isAlphabetic(c)) {ans.append(c);}
            else if (c == '[') {
                count.add(num);
                preStr.add(ans);
                num = 0;
                ans = new StringBuilder();
            }
            else {
                StringBuilder cur = preStr.pop();
                int curCount = count.pop();
                for (int i = 0; i < curCount; i++) {cur.append(ans);}
                ans = cur;
            }
        }

        return ans.toString();
    }
}
```

## 压缩字符串

> 443
>
> *输入：*
>
> *["a","a","b","b","c","c","c"]*
>
> *输出：*
>
> *返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]*

```java
class Solution {
    public int compress(char[] chars) {
        // anchor:字符    write：写的位置    read：读的位置
        int anchor = 0, write = 0;
        for (int read = 0; read < chars.length; read++) {
            if (read + 1 == chars.length || chars[read + 1] != chars[read]) {
                chars[write++] = chars[anchor];
                if (read > anchor) {
                    // 写count,同时预防出现count=10这种情况，所以写成for
                    for (char c : ("" + (read - anchor + 1)).toCharArray()) {       
                        chars[write++] = c;
                    }
                }
                anchor = read + 1;
            }
        }
        return write;
    }
}
```

## 重复的子字符串

> 459
>
> *给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。*

```java
// 字符串匹配
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        return (s + s).indexOf(s, 1) != s.length();
    }
}

// KMP
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        return kmp(s + s, s);
    }

    private boolean kmp(String query, String pattern) {
        int m = query.length(), n = pattern.length();
        int[] fail = new int[n];
        Arrays.fill(fail, -1);

        for (int i = 1; i < n; i++) {
            int j = fail[i - 1];
            while (j != -1 && pattern.charAt(j + 1) != pattern.charAt(i)) {
                j = fail[j];
            }
            if (pattern.charAt(j + 1) == pattern.charAt(i)) {
                fail[i] = j + 1;
            }
        }

        int match = -1;
        for (int i = 1; i < m - 1; i++) {
            while (match != -1 && pattern.charAt(match + 1) != query.charAt(i)) {
                match = fail[match];
            }
            if (pattern.charAt(match + 1) == query.charAt(i)) {
                match++;
                if (match == n - 1) {return true;}
            }
        }

        return false;
    }
}
```

## 环绕字符串中唯一的子字符串

> 467 
>
> 把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 s 看起来是这样的："...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". 
>
> 现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串 s 中 p 的不同的非空子串的数目。 
>
> 注意: p 仅由小写的英文字母组成，p 的大小可能超过 10000。

```java
class Solution {
    public int findSubstringInWraproundString(String p) {
        int[] dp = new int[26];			// 记录 p 中以每个字符结尾的最长连续子串的长度
        char[] charArray = p.toCharArray();

        int count = 0;					// 记录当前连续子串的长度
        for (int i = 0; i < charArray.length; i++) {
            if (i > 0 && (charArray[i] - charArray[i - 1] - 1) % 26 == 0) {count++;}
            else {count = 1;}

            dp[charArray[i] - 'a'] = Math.max(dp[charArray[i] - 'a'], count);
        }

        int ans = Arrays.stream(dp).sum();
        return ans;
    }
}
```

## 串联字符串的最大长度

> 给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。
>
> 请返回所有可行解 s 中最长长度。
>
> 输入：arr = ["un","iq","ue"]
> 输出：4
> 解释：所有可能的串联组合是 "","un","iq","ue","uniq" 和 "ique"，最大长度为 4。

```java
class Solution {
    int ans = 0;

    public int maxLength(List<String> arr) {
        List<Integer> masks = new ArrayList<Integer>();
        for (String s : arr) {
            int mask = 0;
            for (int i = 0; i < s.length(); ++i) {
                int ch = s.charAt(i) - 'a';
                if (((mask >> ch) & 1) != 0) { // 若 mask 已有 ch，则说明 s 含有重复字母，无法构成可行解
                    mask = 0;
                    break;
                }
                mask |= 1 << ch; // 将 ch 加入 mask 中
            }
            if (mask > 0) {
                masks.add(mask);
            }
        }

        backtrack(masks, 0, 0);
        return ans;
    }

    public void backtrack(List<Integer> masks, int pos, int mask) {
        if (pos == masks.size()) {
            ans = Math.max(ans, Integer.bitCount(mask));
            return;
        }
        if ((mask & masks.get(pos)) == 0) { // mask 和 masks[pos] 无公共元素
            backtrack(masks, pos + 1, mask | masks.get(pos));
        }
        backtrack(masks, pos + 1, mask);
    }
}
```

## 最长特殊序列

> 521
>
> 给你两个字符串，请你从这两个字符串中找出最长的特殊序列。
>
> 「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。
>
> 子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。
>
> 输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。

```java
class Solution {
    public int findLUSlength(String a, String b) {
        if (a.equals(b)) {return -1;}
        return Math.max(a.length(), b.length());
    }
}
```

> 522
>
> 给定字符串列表，你需要从它们中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。
>
> 输入将是一个字符串列表，输出是最长特殊序列的长度。如果最长特殊序列不存在，返回 -1 。

```java
// 首先按照长度降序排序所有字符串。
// 然后，依次使用序列中的每个字符串与其他字符串比较，如果不存在字符串是当前字符串的子序列，则返回当前字符串的长度。
// 否则返回 -1。
class Solution {
    public int findLUSlength(String[] strs) {
        Arrays.sort(strs, (a, b) -> b.length() - a.length());

        for (int i = 0; i < strs.length; i++) {
            boolean flag = true;
            for (int j = 0; j < strs.length; j++) {
                if (i == j) {continue;}
                if (isSubsequence(strs[i], strs[j])) {
                    flag = false;
                    break;
                }
            }
            if (flag) {return strs[i].length();}
        }

        return -1;
    }

    private static boolean isSubsequence(String x, String y) {
        int idx = 0;
        for (int i = 0; i < y.length() && idx < x.length(); i++) {
            if (x.charAt(idx) == y.charAt(i)) {
                idx++;
            }
        }
        return idx == x.length();
    }
}
```

## 通过删除字母匹配字典里最长单词

> 524
>
> 给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。

```java
// 直接在未排序的字典 dd 中查找字符串 xx 满足 xx 是 ss 的子序列。
// 如果 xx 被找到了，我们将它与其他匹配的字符串做比较，直到找到长度最长、字典序最小的单词为止。
class Solution {
    public String findLongestWord(String s, List<String> dictionary) {
        String ans = "";
        for (String cur : dictionary) {
            if (isSubsequence(cur, s)) {
                if (cur.length() > ans.length() || (cur.length() == ans.length() && cur.compareTo(ans) < 0)) {
                    ans = cur;
                }
            }
        }
        return ans;
    }

    private static boolean isSubsequence(String x, String y) {
        int idx = 0;
        for (int i = 0; i < y.length() && idx < x.length(); i++) {
            if (x.charAt(idx) == y.charAt(i)) {
                idx++;
            }
        }
        return idx == x.length();
    }
}
```

## 匹配子序列的单词数

> 792
>
> *给定字符串 S 和单词字典 words, 求 words[i] 中是 S 的子序列的单词个数。*

```java
class Solution {
    public int numMatchingSubseq(String s, String[] words) {
        int ans = 0;
        Map<String, Integer> map = new HashMap<>();
        for (String w : words) {map.put(w, map.getOrDefault(w, 0) + 1);}

        for (String cur : map.keySet()) {
            int j = 0;
            for (int i = 0; i < s.length() && j < cur.length(); i++) {
                if (cur.charAt(j) == s.charAt(i)) {
                    j++;
                }
            }
            if (j == cur.length()) {ans += map.get(cur);}
        }
        
        return ans;
    }
}
```

## 自定义字符串排序

> 791
>
> *字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。*
>
> *S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。*
>
> *返回任意一种符合条件的字符串T。*

```java
class Solution {
    public String customSortString(String order, String str) {
        int[] count = new int[26];
        for (char c : str.toCharArray()) {count[c - 'a']++;}

        StringBuilder ans = new StringBuilder();
        // 先找出在 str 中出现的所有的 order 的元素，并且将这些元素按照 order 中出现的相对顺序排序
        for (char c : order.toCharArray()) {
            for (int i = 0; i < count[c - 'a']; i++) {
                ans.append(c);
            }
            count[c - 'a'] = 0;
        }

        // 将 str 中出现的但不在 order 中的元素添加到字符串时
        // 无序关注顺序，因为这些元素并没有在 order 中出现，不需要满足排序关系
        for (char c = 'a'; c <= 'z'; c++) {
            for (int i = 0; i < count[c - 'a']; i++) {
                ans.append(c);
            }
        }

        return ans.toString();
    }
}
```

## 字母大小写全排列

> 784
>
> *给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。*

```java
class Solution {
    public List<String> letterCasePermutation(String s) {
        List<StringBuilder> cur = new ArrayList<>();
        cur.add(new StringBuilder());

        for (char c : s.toCharArray()) {
            int n = cur.size();
            if (Character.isLetter(c)) {
                for (int i = 0; i < n; i++) {
                    cur.add(new StringBuilder(cur.get(i)));
                    cur.get(i).append(Character.toLowerCase(c));
                    cur.get(i + n).append(Character.toUpperCase(c));
                }
            }
            else {
                for (int i = 0; i < n; i++) {
                    cur.get(i).append(c);
                }
            }
        }

        List<String> ans = new ArrayList<>();
        for (StringBuilder sb : cur) {ans.add(sb.toString());}
        return ans;
    }
}
```

## 删除字符串中的所有相邻重复项

> 1047
>
> *给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。*
>
> *在 S 上反复执行重复项删除操作，直到无法继续删除。*
>
> *在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。*

```java
// 递归
class Solution {
    public String removeDuplicates(String s) {
        int n = s.length();
        for (int i = 1; i < n; i++){
            if (s.charAt(i - 1) == s.charAt(i)){
                return removeDuplicates(s.substring(0, i - 1) + removeDuplicates(s.substring(i + 1)));
            }
        }
        return s;
    }
}

// 栈
class Solution {
    public String removeDuplicates(String s) {
        StringBuilder sb = new StringBuilder();
        int idx = 0;
        for (char c : s.toCharArray()) {
            if (idx != 0 && c == sb.charAt(idx - 1)) {
                sb.deleteCharAt(idx - 1);
                idx--;
            }
            else {
                sb.append(c);
                idx++;
            }
        }
        return sb.toString();
    }
}
```

## 词典中最长的单词

> 720
>
> *给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。*
>
> *若无答案，则返回空字符串。*

```java
class Solution {
    public String longestWord(String[] words) {
        Set<String> wordSet = new HashSet<>(Arrays.asList(words));
        Arrays.sort(words, (a, b) -> a.length() == b.length() ? a.compareTo(b) : b.length() - a.length());

        for (String s : words) {
            boolean flag = true;
            for (int i = 1; i < s.length(); i++) {
                if (!wordSet.contains(s.substring(0, i))) {
                    flag = false;
                    break;
                }
            }
            if (flag) {return s;}
        }

        return "";
    }
}
```

## 原子的数量

> 726
>
> *给定一个化学式formula（作为字符串），返回每种原子的数量。*
>
> *原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。*
>
> *如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。*
>
> *两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。*
>
> *一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。*
>
> *给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。*

```java
class Solution {
    public String countOfAtoms(String formula) {
        int N = formula.length();
        Stack<Map<String, Integer>> stack = new Stack();
        stack.push(new TreeMap());

        for (int i = 0; i < N;) {
            if (formula.charAt(i) == '(') {
                stack.push(new TreeMap());
                i++;
            } else if (formula.charAt(i) == ')') {
                Map<String, Integer> top = stack.pop();
                int iStart = ++i, multiplicity = 1;
                while (i < N && Character.isDigit(formula.charAt(i))) i++;
                if (i > iStart) multiplicity = Integer.parseInt(formula.substring(iStart, i));
                for (String c: top.keySet()) {
                    int v = top.get(c);
                    stack.peek().put(c, stack.peek().getOrDefault(c, 0) + v * multiplicity);
                }
            } else {
                int iStart = i++;
                while (i < N && Character.isLowerCase(formula.charAt(i))) i++;
                String name = formula.substring(iStart, i);
                iStart = i;
                while (i < N && Character.isDigit(formula.charAt(i))) i++;
                int multiplicity = i > iStart ? Integer.parseInt(formula.substring(iStart, i)) : 1;
                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + multiplicity);
            }
        }

        StringBuilder ans = new StringBuilder();
        for (String name: stack.peek().keySet()) {
            ans.append(name);
            int multiplicity = stack.peek().get(name);
            if (multiplicity > 1) ans.append("" + multiplicity);
        }
        return new String(ans);
    }
}
```

## 划分字母区间

> 763
>
> *字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。*
>
> *返回一个表示每个字符串片段的长度的列表。*

```java
// 由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。
// 在得到每个字母最后一次出现的下标位置之后，可以使用贪心的方法将字符串划分为尽可能多的片段
class Solution {
    public List<Integer> partitionLabels(String s) {
        int[] dict = new int[26];
        for (int i = 0; i < s.length(); i++) {
            dict[s.charAt(i) - 'a'] = i;
        }

        List<Integer> ans = new ArrayList<>();
        int left = 0, right = 0;
        for (int i = 0; i < s.length(); i++) {
            right = Math.max(right, dict[s.charAt(i) - 'a']);
            if (i == right) {
                ans.add(right - left + 1);
                left = right + 1;
            }
        }

        return ans;
    }
}
```

## 在LR字符串中交换相邻字符

> 777
>
> *在一个由 'L' , 'R' 和 'X' 三个字符组成的字符串（例如"RXXLRXRXL"）中进行移动操作。一次移动操作指用一个"LX"替换一个"XL"，或者用一个"XR"替换一个"RX"。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。*

```java
class Solution {
    public boolean canTransform(String start, String end) {
        if (!start.replace("X", "").equals(end.replace("X", ""))) {return false;}

        int t = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == 'L') {
                while (end.charAt(t) != 'L') {t++;}
                if (i < t++) {return false;}
            }
        }

        t = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == 'R') {
                while (end.charAt(t) != 'R') {t++;}
                if (i > t++) {return false;}
            }
        }

        return true;
    }
}
```

## 连接词

> 472
>
> 给定一个 不含重复 单词的字符串数组 words ，编写一个程序，返回 words 中的所有 连接词 。
>
> 连接词 的定义为：一个字符串完全是由至少两个给定数组中的单词组成的。

```java
/**
1 把所有单词加入集合
2 对于每个单词，调用辅助递归函数判断
3 在辅助递归函数中使用index参数记录递归次数，避免单词本身对结果产生影响
4 辅助递归函数的终止条件：一旦传入的字符串存在set中并且不是第一次递归，返回true
5 对每一个s[0-i]，判断是否存在在set中，如果存在截取后部分字符串递归
6 只要有任何一个截取方式能成功组合即返回true避免无意义计算
7 若所有截断方式都无法成功组合返回false
**/

class Solution {
    public List<String> findAllConcatenatedWordsInADict(String[] words) {
        Set<String> set = new HashSet<>(Arrays.asList(words));
        List<String> ans = new ArrayList<>();
        for (String s : words) {
            if (myMethod(s, set, 0)) {
                ans.add(s);
            }
        }
        return ans;
    }

    private boolean myMethod(String s, Set<String> set, int index) {
        if (set.contains(s) && index != 0) {return true;}
        for (int i = 1; i < s.length(); i++) {
            String tmp = s.substring(0, i);
            if (set.contains(tmp)) {
                if (myMethod(s.substring(i), set, index + 1)) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

## 复原IP地址

> 93
>
> 给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。
>
> 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
>
> 例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
>
> 示例 1：
>
> 输入：s = "25525511135"
> 输出：["255.255.11.135","255.255.111.35"]
> 示例 2：
>
> 输入：s = "0000"
> 输出：["0.0.0.0"]

```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        List<String> ans = new ArrayList<>();
        int[] segment = new int[4];
        dfs(s, ans, segment, 0, 0);
        return ans;
    }

    private static void dfs(String s, List<String> ans, int[] segment, int segId, int segStart) {
        // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
        if (segId == 4) {
            if (segStart == s.length()) {
                StringBuilder ipAddr = new StringBuilder();
                for (int i = 0; i < 4; ++i) {
                    ipAddr.append(segment[i]);
                    if (i != 3) {
                        ipAddr.append('.');
                    }
                }
                ans.add(ipAddr.toString());
            }
            return;
        }

        // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
        if (segStart == s.length()) {return;}

        // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
        if (s.charAt(segStart) == '0') {
            segment[segId] = 0;
            dfs(s, ans, segment, segId + 1, segStart + 1);
        }

        // 一般情况，枚举每一种可能性并递归
        int addr = 0;
        for (int segEnd = segStart; segEnd < s.length(); ++segEnd) {
            addr = addr * 10 + (s.charAt(segEnd) - '0');
            if (addr > 0 && addr <= 0xFF) {
                segment[segId] = addr;
                dfs(s, ans, segment, segId + 1, segEnd + 1);
            } else {
                break;
            }
        }
    }
}
```

## 简化Unix路径

> 71
>
> *以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。*

```java
class Solution {
    public String simplifyPath(String path) {
        if (path == null || path.length() == 0) {return "/";}
        int n = path.length();
        
        List<String> names = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (path.charAt(i) != '/'){
                int j = i;
                while (j < n && path.charAt(j) != '/') {j++;}
                names.add(path.substring(i, j));
                i = j;
            }
        }

        List<String> ans = new ArrayList<>();
        for (int i = 0; i < names.size(); i++) {
            if (names.get(i).equals("..")) {
                if (ans.size() > 0) {
                    ans.remove(ans.size() - 1);
                }
            }
            else if (!names.get(i).equals(".")) {
                ans.add(names.get(i));
            }
        }
        return "/" + String.join("/", ans);
    }
}
```

## 原子的数量

> 726
>
> *给定一个化学式formula（作为字符串），返回每种原子的数量。*
>
> *原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。*
>
> *如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。*
>
> *两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。*
>
> *一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。*
>
> *给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。*

```java
class Solution {
    public String countOfAtoms(String formula) {
        int N = formula.length();
        Stack<Map<String, Integer>> stack = new Stack();
        stack.push(new TreeMap());

        for (int i = 0; i < N;) {
            if (formula.charAt(i) == '(') {
                stack.push(new TreeMap());
                i++;
            } else if (formula.charAt(i) == ')') {
                Map<String, Integer> top = stack.pop();
                int iStart = ++i, multiplicity = 1;
                while (i < N && Character.isDigit(formula.charAt(i))) i++;
                if (i > iStart) multiplicity = Integer.parseInt(formula.substring(iStart, i));
                for (String c: top.keySet()) {
                    int v = top.get(c);
                    stack.peek().put(c, stack.peek().getOrDefault(c, 0) + v * multiplicity);
                }
            } else {
                int iStart = i++;
                while (i < N && Character.isLowerCase(formula.charAt(i))) i++;
                String name = formula.substring(iStart, i);
                iStart = i;
                while (i < N && Character.isDigit(formula.charAt(i))) i++;
                int multiplicity = i > iStart ? Integer.parseInt(formula.substring(iStart, i)) : 1;
                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + multiplicity);
            }
        }

        StringBuilder ans = new StringBuilder();
        for (String name: stack.peek().keySet()) {
            ans.append(name);
            int multiplicity = stack.peek().get(name);
            if (multiplicity > 1) ans.append("" + multiplicity);
        }
        return new String(ans);
    }
}
```

