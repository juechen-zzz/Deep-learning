## 1 单例模式

> 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
>
> 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

- 单例类只能有一个实例。
- 单例类必须自己创建自己的唯一实例。
- 单例类必须给所有其他对象提供这一实例。

**实现**

懒汉式（线程不安全）

> 这是最基本的实现方式，第一次调用才初始化，实现了懒加载的特性。多线程场景下禁止使用，因为可能会产生多个对象，不再是单例。

```java
public class Singleton {
    private static Singleton singleton;
    private Singleton() {}
    public static Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
```

懒汉式（线程安全，方法上加同步锁）

> 获取实例的getInstance()方法上加了同步锁。保证了多线程场景下的单例。但是效率会有所折损

```java
public class Singleton {
    private static Singleton singleton;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
```

双重校验锁（线程安全，效率高）

> 此种实现中不用每次需要获得锁，减少了获取锁和等待的事件。
> 注意volatile关键字的使用，保证了各线程对singleton静态实例域修改的可见性。

```java
public class Singleton {
	private volatile static Singleton singleton;
	private Singleton() {}
	public static Singleton getSingleton() {
		if (singleton == null) {
			synchronized (Singleton.class) {
				if (singleton == null) {
						singleton = new Singleton();
				}
			}
		}
		return singleton;
	}
}
```

恶汉式

> 饿汉式更为安全，在类加载的时候就已经自行创建了实例，getinstance方法里面一直引用的就是这个实例，而且永远不会释放，一直存在内存中，知道程序结束
> **优点：** 没有加锁，执行效率会提高。
> **缺点：** 类加载时就初始化，浪费内存。

```java
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){} 
    public static Singleton getInstance() {  
    	return instance;  
    }  
}
```

## 2 生产者消费者模式

```java

package com.zhb.juc;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 使用synchronize wait notify/notifyall实现生产者消费者模式
 */

class ShareDataV1 {
    public static AtomicInteger atomicInteger = new AtomicInteger();
    public volatile boolean flag = true;
    public static final int MAX_COUNT = 10;
    public static final List<Integer> pool = new ArrayList<>();

    public void produce() {
        // 判断，干活，通知
        while (flag) {
            // 每隔 1000 毫秒生产一个商品
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
            synchronized (pool) {
                //池子满了，生产者停止生产
                //埋个坑，这里用的if
                //TODO 判断
                if (pool.size() == MAX_COUNT) {
                    try {
                        System.out.println("pool is full, wating...");
                        pool.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //干活
                pool.add(atomicInteger.incrementAndGet());
                System.out.println("produce number:" + atomicInteger.get() + "\t" + "current size:" + pool.size());
                //通知
                pool.notifyAll();
            }
        }
    }

    public void consumue() {
        // 判断，干活，通知
        while (flag) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            synchronized (pool) {
                //池子满了，生产者停止生产
                //埋个坑，这里用的if
                //TODO 判断
                if (pool.size() == 0) {
                    try {
                        System.out.println("pool is empty, wating...");
                        pool.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //干活
                int temp = pool.get(0);
                pool.remove(0);
                System.out.println("cousume number:" + temp + "\t" + "current size:" + pool.size());
                //通知
                pool.notifyAll();
            }
        }
    }

    public void stop() {
        flag = false;
    }
}

public class ProducerConsumer_V1 {
    public static void main(String[] args) {
        ShareDataV1 shareDataV1 = new ShareDataV1();
        new Thread(() -> {
            shareDataV1.produce();
        }, "AAA").start();

        new Thread(() -> {
            shareDataV1.consumue();
        }, "BBB").start();

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        shareDataV1.stop();
    }
}
```

## 3 线程打印

```java
/**
 * @description: 两个线程交替打印奇数和偶数
 * @author: Komorebi
 * @time: 2021/4/28 10:45
 */

public class ThreadTest implements Runnable {
    private boolean run;
    private Object lock;
    private int num;

    public ThreadTest(boolean run, Object lock, int num) {
        this.run = run;
        this.lock = lock;
        this.num = num;
    }

    @Override
    public void run() {
        synchronized(lock) {
            while (num <= 100) {
                if (run) {
                    run = false;
                }
                else {
                    try {
                        lock.wait();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }

                System.out.println(num);
                num += 2;
                lock.notify();
            }
        }
    }

    public static void main(String[] args) {
        Object lock = new Object();
        Thread t1 = new Thread(new ThreadTest(true, lock, 1));
        Thread t2 = new Thread(new ThreadTest(false, lock, 2));

        t2.start();
        t1.start();
    }
}
```

