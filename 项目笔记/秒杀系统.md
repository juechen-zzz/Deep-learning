[TOC]

# 秒杀系统

## 一、项目框架

### 1.1 SpringBoot环境搭建

1. 新建Maven项目，添加依赖(父依赖SpringBoot，还有正常依赖web和thymeleaf)

	```xml
	<!--SpringBoot-->
	<parent>
	    <artifactId>spring-boot-starter-parent</artifactId>
	    <groupId>org.springframework.boot</groupId>
	    <version>2.4.2</version>
	</parent>
	
	<!--Web-->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-web</artifactId>
	</dependency>
	<!--thymeleaf-->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-thymeleaf</artifactId>
	</dependency>
	```

2. 构建项目结构
	![image-20210121101726052](../images/image-20210121101726052.png)

3. 编写测试类

	```java
	@Controller
	@RequestMapping("/demo")
	public class SampleController {
	    @RequestMapping("/thymeleaf")
	    public String thymeleaf(Model model) {
	        model.addAttribute("name", "komorebi");
	        return "hello";
	    }
	}
	```

	```html
	<!DOCTYPE HTML>
	<html xmlns:th="http://www.thymeleaf.org">
	<head>
	    <title>hello</title>
	    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	</head>
	<body>
	<p th:text="'hello:'+${name}" ></p>
	</body>
	</html>
	```

4. localhost:8080/demo/thymeleaf测试

### 1.2 Result结果封装

result.java

```java
public class Result<T> {
	private int code;
	private String msg;
	private T data;

	/**
	 * 成功时候的调用
	 * */
	public static <T> Result<T> success(T data){
		return new  Result<T>(data);
	}
	
	/**
	 * 失败时候的调用
	 * */
	public static <T> Result<T> error(CodeMsg cm){
		return new  Result<T>(cm);
	}
	
	private Result(T data) {
		this.code = 0;
		this.msg = "success";
		this.data = data;
	}
	
	private Result(CodeMsg cm) {
		if(cm == null) {
			return;
		}
		this.code = cm.getCode();
		this.msg = cm.getMsg();
	}

	public int getCode() {
		return code;
	}
	public String getMsg() {
		return msg;
	}
	public T getData() {
		return data;
	}
}
```

CodeMsg.java

```java
public class CodeMsg {
	private int code;
	private String msg;
	
	//通用异常
	public static CodeMsg SUCCESS = new CodeMsg(0, "success");
	public static CodeMsg SERVER_ERROR = new CodeMsg(500100, "服务端异常");
	//登录模块 5002XX
	
	//商品模块 5003XX
	
	//订单模块 5004XX
	
	//秒杀模块 5005XX
	
	
	private CodeMsg(int code, String msg) {
		this.code = code;
		this.msg = msg;
	}
	
	public int getCode() {
		return code;
	}
	public String getMsg() {
		return msg;
	}
}
```

### 1.3 集成Mybatis+Druid

1. 导包

	```xml
	<!--Mybatis-->
	<dependency>
	    <groupId>org.mybatis.spring.boot</groupId>
	    <artifactId>mybatis-spring-boot-starter</artifactId>
	    <version>2.1.3</version>
	</dependency>
	<!--MySQL-->
	<dependency>
	    <groupId>mysql</groupId>
	    <artifactId>mysql-connector-java</artifactId>
	    <version>5.1.49</version>
	</dependency>
	<!--Druid-->
	<dependency>
	    <groupId>com.alibaba</groupId>
	    <artifactId>druid</artifactId>
	    <version>1.2.4</version>
	</dependency>
	```

2. 配置proerties

	```properties
	# mybatis
	mybatis.type-aliases-package=com.komorebi.domain
	mybatis.configuration.map-underscore-to-camel-case=true
	mybatis.configuration.default-fetch-size=100
	mybatis.configuration.default-statement-timeout=3000
	mybatis.mapperLocations = classpath:com/komorebi/dao/*.xml
	
	# Druid
	spring.datasource.url=jdbc:mysql://127.0.0.1:3306/spike?useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&useSSL=false
	spring.datasource.username=root
	spring.datasource.password=123456
	spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
	spring.datasource.type=com.alibaba.druid.pool.DruidDataSource 
	spring.datasource.filters=stat
	spring.datasource.maxActive=2
	spring.datasource.initialSize=1
	spring.datasource.maxWait=60000
	spring.datasource.minIdle=1
	spring.datasource.timeBetweenEvictionRunsMillis=60000
	spring.datasource.minEvictableIdleTimeMillis=300000
	spring.datasource.validationQuery=select 'x'
	spring.datasource.testWhileIdle=true
	spring.datasource.testOnBorrow=false
	spring.datasource.testOnReturn=false
	spring.datasource.poolPreparedStatements=true
	spring.datasource.maxOpenPreparedStatements=20
	```

3. 实体类User+UserDao+UserService，最后Controller

	```java
	@RequestMapping("/db/get")
	@ResponseBody
	public Result<User> dbGet() {
	    User user = userService.getById(1);
	    return Result.success(user);
	}
	```

4. 测试![image-20210121145235602](../images/image-20210121145235602.png)

### 1.4 集成Redis+通用缓存Key封装

* 添加Jedis依赖

* 添加Fastjson依赖

	```xml
	<!--Jedis-->
	<dependency>
	    <groupId>redis.clients</groupId>
	    <artifactId>jedis</artifactId>
	    <version>3.2.0</version>
	</dependency>
	<!--fastjson-->
	<dependency>
	    <groupId>com.alibaba</groupId>
	    <artifactId>fastjson</artifactId>
	    <version>1.2.75</version>
	</dependency>
	```

	

## 二、实现登录功能

### 2.1 数据库设计

<img src="../images/image-20210122152444931.png" alt="image-20210122152444931" style="zoom:50%;" />

### 2.2 明文密码两次MD5处理

两次MD5：

* 用户端：Pass = MD5（明文+固定Salt）

* 服务端：Pass = MD5（用户输入+随机Salt）

	```java
	public class MD5Util {
	    public static String md5(String s) {
	        return DigestUtils.md5Hex(s);
	    }
	
	    private static final String salt = "1a2b3c4d";
	
	    public static String inputPassToFormPass(String inputPass) {
	        String s = "" + salt.charAt(0) + salt.charAt(2) + inputPass + salt.charAt(5) + salt.charAt(4);
	        return md5(s);
	    }
	
	    public static String formPassToDBPass(String formPass, String salt) {
	        String s = "" + salt.charAt(0) + salt.charAt(2) + formPass + salt.charAt(5) + salt.charAt(4);
	        return md5(s);
	    }
	
	    public static String inputPassToDBPass(String inputPass, String saltDB) {
	        String formPass = inputPassToFormPass(inputPass);
	        String dbPass = formPassToDBPass(formPass, saltDB);
	        return dbPass;
	    }
	
	    public static void main(String[] args) {
	        System.out.println(inputPassToFormPass("123456"));
	        System.out.println(formPassToDBPass(inputPassToFormPass("123456"), "1a2b3c4d"));
	        System.out.println(inputPassToDBPass("123456", "1a2b3c4d"));
	    }
	}
	```

### 2.3 JSR303参数检验+全局异常处理器

1. Controller参数前加上@Valid

2. LoginVo对象在需要校验的参数前加上注解

3. 编写IsMobile接口和IsMobileValidator实现类

	```java
	@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
	@Retention(RUNTIME)
	@Documented
	@Constraint(validatedBy = {IsMobileValidator.class })
	public @interface IsMobile {
		
		boolean required() default true;
		
		String message() default "手机号码格式错误";
	
		Class<?>[] groups() default { };
	
		Class<? extends Payload>[] payload() default { };
	}
	
	```

	```java
	public class IsMobileValidator implements ConstraintValidator<IsMobile, String> {
	
		private boolean required = false;
		
		public void initialize(IsMobile constraintAnnotation) {
			required = constraintAnnotation.required();
		}
	
		public boolean isValid(String value, ConstraintValidatorContext context) {
			if(required) {
				return ValidatorUtil.isMobile(value);
			}else {
				if(StringUtils.isEmpty(value)) {
					return true;
				}else {
					return ValidatorUtil.isMobile(value);
				}
			}
		}
	}
	```

4. 全局异常处理

	```java
	@ControllerAdvice
	@ResponseBody
	public class GlobalExceptionHandler {
	    @ExceptionHandler(value = Exception.class)
	    public Result<String> exceptionHandler(HttpServletRequest request, Exception e) {
	        if (e instanceof BindException) {
	            BindException ex = (BindException) e;
	            List<ObjectError> errors = ex.getAllErrors();
	            ObjectError error = errors.get(0);
	            String msg = error.getDefaultMessage();
	            return Result.error(CodeMsg.BIND_ERROR.fillArgs(msg));
	        }
	        else {
	            return Result.error(CodeMsg.SERVER_ERROR);
	        }
	    }
	}
	```

	```java
	public class GlobalException extends RuntimeException {
	    private static final long serialVersionUID = 1L;
	
	    private CodeMsg cm;
	
	    public GlobalException(CodeMsg cm) {
	        super(cm.toString());
	        this.cm = cm;
	    }
	
	    public CodeMsg getCm() {
	        return cm;
	    }
	}
	```

### 2.4 分布式Session

1. Service中生成cookie

	```java
	public void addCookie(HttpServletResponse response, SpikeUser user) {
	    String token = UUIDUtil.uuid();
	    redisService.set(SpikeUserKey.token, token, user);
	
	    Cookie cookie = new Cookie(COOKIE_NAME_TOKEN, token);
	    cookie.setMaxAge(SpikeUserKey.token.expireSeconds());
	    cookie.setPath("/");
	
	    response.addCookie(cookie);
	}
	```

2. Controller中读取cookie

	```java
	@RequestMapping("/to_list")
	public String list(Model model, 
	                   @CookieValue(value = SpikeUserService.COOKIE_NAME_TOKEN, required = false) String cookieToken,
	                   @RequestParam(value = SpikeUserService.COOKIE_NAME_TOKEN, required = false) String paramToken) {
	    if (StringUtils.isEmpty(cookieToken) && StringUtils.isEmpty(paramToken)) {
	        return "login";
	    }
	
	    String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;
	    SpikeUser user = spikeUserService.getByToken(token);
	    model.addAttribute("user", user);
	    return "goods_list";
	}
	```

3. 封装Controller中的功能，编写WebConfig和UserArgumentResolver

	```java
	@Configuration
	public class WebConfig extends WebMvcConfigurerAdapter {
	    @Autowired
	    UserArgumentResolver userArgumentResolver;
	
	    @Override
	    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
	        argumentResolvers.add(userArgumentResolver);
	    }
	}
	```

	```java
	@Service
	public class UserArgumentResolver implements HandlerMethodArgumentResolver {
	    @Autowired
	    SpikeUserService spikeUserService;
	
	    @Override
	    public boolean supportsParameter(MethodParameter methodParameter) {
	        Class<?> clazz = methodParameter.getParameterType();
	        return clazz == SpikeUser.class;
	    }
	
	    @Override
	    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {
	        HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);
	        HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse.class);
	
	        String paramToken = request.getParameter(SpikeUserService.COOKIE_NAME_TOKEN);
	        String cookieToken = getCookieValue(request, SpikeUserService.COOKIE_NAME_TOKEN);
	
	        if (StringUtils.isEmpty(cookieToken) && StringUtils.isEmpty(paramToken)) {
	            return null;
	        }
	
	        String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;
	        return spikeUserService.getByToken(response, token);
	    }
	
	    private String getCookieValue(HttpServletRequest request, String cookieNameToken) {
	        Cookie[] cookies = request.getCookies();
	        for (Cookie cookie : cookies) {
	            if (cookie.getName().equals(cookieNameToken)) {
	                return cookie.getValue();
	            }
	        }
	        return null;
	    }
	}
	```

## 三、实现秒杀功能

### 3.1 数据库设计

### 3.2 商品列表页

### 3.3 商品详情页

### 3.4 订单详情页

## 四、JMeter压测

### 4.1 JMeter入门

### 4.2 自定义变量模拟多用户

### 4.3 JMeter命令行使用

### 4.4 SpringBoot打war包

## 五、页面优化技术

### 5.1 页面缓存+URL缓存+对象缓存

### 5.2 页面静态化，前后端分离

### 5.3 静态资源优化

### 5.4 CDN优化

## 六、接口优化

### 6.1 RabbitMQ安装与SpringBoot集成

### 6.2 访问Nginx水平扩展

### 6.3 压测

## 七、安全优化

### 7.1 秒杀接口地址隐藏

### 7.2 数学公式验证码

### 7.3 接口防刷