# 红包雨

> 模拟企业年会下的红包雨场景，设计一套红包雨项目，在某段时间内随机发放不同的礼品

## 一、系统描述及要求

**并发性：**

* 抽奖系统比如涉及到访问量大的问题。系统涉及所面临的第一关。怎样设计系统以达到如此高并发情况下的及时响应是本项目的重中之重。

**库存控制：**

* 抽奖面临的必然是奖品。数量控制是必须要做到精准吻合。不允许出现设置了5个奖品，最终6人中奖这种类似的问题出现。其中的本质是奖品库存的控制。

**投放策略：**

* 在活动时间段内，管理员设置好的一堆奖品如何投放？红包何时出现？年会奖品什么时候可以被抽中？这些都涉及到投放策略。 

**边界控制：**

* 活动何时开始？何时结束？倒计时如何控制。这涉及到活动的边界。开始前要提防用户提前进入抽奖。结束后要及时反馈结果给用户，告知活动已结束。

**活动自由配置：**

* 活动的配置由后台管理员完成，可以自由配置活动的开始结束时间，主题、活动简介、有哪些奖品、不同等级的用户中奖的策略。这就要求系统必须具备足够的业务灵活度。

**中奖策略：**

* 每个用户参与抽奖后，要遵从后台管理员所设定的中奖策略，典型的场景是针对用户设置最大中奖数。一旦用户中奖后，要进入计数，达到最大中奖数后，即使活动未结束，用户继续参与，也不能再让其中奖。而是将奖品机会倾向于其他参与者。下面的章节中会为大家展示如何根据后台策略精确控制用户中奖数量。



## 二、中间件

### 2.1 zookeeper

> Zookeeper是一个分布式服务框架，是Apache Hadoop的一个子项目，主要是用来解决分布式应用中经常遇到的一些数据管理问题。如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。

**节点类型**

* 临时节点：临时节点的生命周期和客户端会话绑定在一起，客户端会话失效，则这个节点就会被自动清除
* 永久节点：该数据节点被创建后，就会一直存在于zookeeper服务器上，直到有删除操作来主动删除这个节点。

**使用场景**

* 配置中心：将配置数据写到zk节点上，供各个分布式机器获取配置，同时监听自己对应的节点，实现配置信息的集中式管理和动态更新。
* 命名服务：在分布式系统中，通过使用命名服务
	* 客户端应用能够根据指定名字来获取资源或服务的地址、提供者信息。
	* 被命名的实体通常可以是集群中的机器，提供的服务地址、远程对象等，这些都可以统称为名字（Name）。
	* 通过调用zk提供的创建节点的API，能够创建一个全局唯一的path，这个path就可以称为一个名称。
* 分布式通知：zk的watcher注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理。不同系统都对zk上同一个znode进行注册，监听znode的变化（包括znode本身内容及子节点的），其中一个系统update了znode，那么另一个系统能够收到通知，并作出相应处理。
* 选主：利用zk的一致性，能保证高并发场景下节点创建的全局唯一性。即，同时有多个客户端请求创建/currentMaster节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻松的在分布式环境中进行集群选取。
* 分布式锁：zk保证了数据的一致性，主要得益于zk的节点创建和事件监听机制。锁服务可以分为两类，一个是保持独占，另一个是控制时序。 

**高可用**

集群与选主：以5台机器启动时场景为主，过程如下：

1. 服务器1启动，此时只有它一台服务器启动了，它发出去的报没有任何响应，所以它的选举状态一直是LOOKING状态。
2. 服务器2启动，它与最开始启动的服务器1进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以id值较大的服务器2胜出，但是由于没有达到超过半数以上的服务器都同意选举它（这个例子中的半数以上是3），所以服务器1，2还是继续保持LOOKING状态。
3. 服务器3启动，根据前面的理论分析，服务器3成为服务器1，2，3中的老大，而与上面不同的是，此时有三台服务器选举了它，所以它成为了这次选举的leader。
4. 服务器4启动，根据前面的分析，理论上服务器4应该是服务器1，2，3，4中最大的，但是由于前面已经有半数以上的服务器选举了服务器3，状态是following，所以它只能接收当小弟的命了。
5. 服务器5启动，同4一样，当小弟。

 

### 2.2 nginx

> Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件(IMAP/POP3)代理服务器，在BSD-like协议下发行。特点是占用内存少，并发能力强。

**动静分离**

<img src="../images/image-20210412183516801.png" alt="image-20210412183516801" style="zoom:50%;" />

* 静态资源：由Nginx作为web服务器身份，直接返回
* 动态资源：Nginx将请求转发出去，交给后端应用服务器处理

**负载均衡**

​		当并发量较高时，需要多台服务器集群提升并行处理能力。



## 三、系统设计

<img src="../images/image-20210420192732052.png" alt="image-20210420192732052" style="zoom:50%;" />

### 3.1 数据库

1. 会员表（card_user）
	![image-20210420194003114](../images/image-20210420194003114.png)

2. 奖品表（card_product）
	![image-20210420201216486](../images/image-20210420201216486.png)

3. 活动表（card_game）
	![image-20210420201918118](../images/image-20210420201918118.png)

4. 活动-奖品关联表（card_game_product）
	![image-20210420203410610](../images/image-20210420203410610.png)

5. 规则表（card_game_rules）
	![image-20210420203510793](../images/image-20210420203510793.png)

6. 用户-活动关联表（card_user_game）
	![image-20210420203546318](../images/image-20210420203546318.png)

7. 用户-中奖记录表（card_user_hit）
	![image-20210420203908137](../images/image-20210420203908137.png)

8. 新建三个视图，后续使用

	```sql
	-- view_game_productnum
	select `c`.`gameid` AS `gameid`,sum(`c`.`amount`) AS `num` from `card_game_product` `c` group by `c`.`gameid`
	-- view_user_hitnum
	select `h`.`userid` AS `userid`,count(`h`.`id`) AS `num` from `card_user_hit` `h` group by `h`.`userid`
	-- view_game_hitnum
	select `h`.`gameid` AS `gameid`,count(`h`.`id`) AS `num` from `card_user_hit` `h` group by `h`.`gameid`
	```

9. 创建字典表（sys_dict）
	![image-20210420211345192](../images/image-20210420211345192.png)

10. 录入字典表
	![image-20210420212029481](../images/image-20210420212029481.png)

11. 

