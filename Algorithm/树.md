# Tree题型汇总

## 1 遍历

* 前序(Preorder)、中序(Inorder)、后序(Postorder)

```python
# 回溯模板
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        
        def helper(root):
            if root == None: return   # 叶节点没有子树，递归终止
            helper(root.left)   # 遍历左
            res.append(root.val)  # 根
            helper(root.right)  # 遍历右
            
        helper(root)
        return res
```

* 中序-栈方法

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res, stack = [], []
        while True:
            while root:
                stack.append(root)
                root = root.left
            if not stack: 
            	return res
            node = stack.pop()
            res.append(node.val)
            root = node.right
```

* 前序-栈方法

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res, stack = [], []
        while True:
            while root:
                res.append(root.val)
                stack.append(root)
                root = root.left
            if not stack: 
            	return res
            node = stack.pop()
            root = node.right
```

* 层序遍历、Z型遍历

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        queue = []
        ans = []
        if not root: return ans
        queue.append(root)
        while queue:
            sub_ans = []
            l = len(queue)
            for i in range(l):
                node = queue.pop(0)
                sub_ans.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            ans.append(sub_ans)
        return ans
```

```python
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        queue = []
        ans = []
        if not root: return ans
        queue.append(root)
        left_to_right = True
        while queue:
            sub_ans = []
            l = len(queue)
            for i in range(l):
                node = queue.pop(0)
                sub_ans.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            if left_to_right:
                ans.append(sub_ans)
            else:
                ans.append(sub_ans[::-1])
            left_to_right = not left_to_right
        return ans
```



## 2 二叉搜索树

* 判断是否为二叉搜索树（中序遍历+判断是否有序即可）

```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        res = []
        def helper(root):
            if not root:
                return([])
            return (helper(root.left)+[root.val]+helper(root.right))

        res = helper(root)
        for i in range(len(res)-1):
            if(res[i]>=res[i+1]):
                return False
        return True
```

* 给定n，问有多少种构建方式

```python
class Solution:
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        G = [0]*(n+1)
        G[0], G[1] = 1, 1

        for i in range(2, n+1):
            for j in range(1, i+1):
                G[i] += G[j-1] * G[i-j]

        return G[n]
```

* 给定n，返回所有的构建方案

```python
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        if n == 0: return []
        
        def build_trees(left, right):
            all_trees = []
            if left > right: return [None]
            for i in range(left, right+1):
                left_trees = build_trees(left, i-1)
                right_trees = build_trees(i+1, right)
                for l in left_trees:
                    for r in right_trees:
                        cur_tree = TreeNode(i)
                        cur_tree.left = l
                        cur_tree.right = r
                        all_trees.append(cur_tree)
            return all_trees
        
        res = build_trees(1, n)
        return res
```



## 3 二叉树操作

* 反转二叉树

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root: return None
        return TreeNode(root.val, self.invertTree(root.right), self.invertTree(root.left))
```

* 二叉搜索树的最低共同祖先

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        while (root.val - p.val) * (root.val - q.val) > 0:
            if p.val > root.val:
                root = root.right
            else:
                root = root.left
        return root
```

* 二叉树的最低共同祖先

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q: return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if not left: return right
        if not right: return left
        return root
```

* 二叉树的所有路径

```python
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        if not root: return []
        if root.left is None and root.right is None: return [str(root.val)]
        sub_paths = self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)
        return [str(root.val) + "->" + s for s in sub_paths]
```

