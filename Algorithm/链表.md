# Linked-list

## 1 成环判断

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# use set，此方法也可以返回出成环的那个节点
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        node = set()
        while head:
            if head in node: return True	# return head
            node.add(head)
            head = head.next
        return False											# return None

# double *	首选
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        slow = fast = head
        while fast and fast.next:  # 防止head为空和出现空指针的next的情况
            slow = slow.next
            fast = fast.next.next
            if slow is fast:
                return True
        return False
```



## 2 重排

* 两两交换1->2->3->4 --> 2->1->4->3

```python
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        if head == None: return None
        cur = ListNode(-1)
        cur.next = head
        p = cur
        while p.next and p.next.next:
            n2 = p.next
            n1 = n2.next
            n3 = n1.next
            
            p.next = n1
            n1.next = n2
            n2.next = n3
            
            p = n2
        return cur.next
```

* 1-2-3-4-5-6-7  --> 1-7-2-6-3-5-4

```python
class Solution(object):
    def reorderList(self, head):
        """
        :type head: ListNode
        :rtype: None Do not return anything, modify head in-place instead.
        """
        if not head: return None
        p = head
        stack = []
        while p:
            stack.append(p)
            p = p.next

        n = len(stack)
        # 找到中点前一个位置 
        count = (n - 1) // 2
        p = head
        while count:
            # 弹出栈顶
            tmp = stack.pop()
            # 与链头拼接
            tmp.next = p.next
            p.next  = tmp
            # 移动一个位置
            p = tmp.next
            count -= 1
        stack.pop().next = None
```

* 两链表融合

```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        cur = head = ListNode(-1)
        while l1 and l2:
            if l1.val < l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        if l1: cur.next = l1
        if l2: cur.next = l2
        return head.next
```



## 3 插入排序

```python
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        first = ListNode(-1)
        cur = first
        while head:
            if cur.val > head.val:
                cur = first
            while cur.next and cur.next.val < head.val:
                cur = cur.next
            
            cur.next, cur.next.next, head = head, cur.next, head.next

        return first.next
```



## 4 删除节点

* 删除指定节点

```python
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        if not head: return None
        cur = head
        pre = None
        while cur is not None:
            if cur.val == val:
                if pre:
                    pre.next = cur.next
                else:
                    head = head.next
            else:
                pre = cur
            cur = cur.next
        return head
```

* 删除倒数第n个节点

```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        if head.next == None: return
        pre = cur = head
        for i in range(n):
            pre = pre.next
        if pre == None: return head.next
        else:
            while pre.next:
                pre = pre.next
                cur = cur.next
            cur.next = cur.next.next
            return head
```



## 5 反转

* 反转全部

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if head == None: return None
        stack = []
        while head:
            stack.append(head)
            head = head.next
        tmp = cur = ListNode(-1)
        while stack:
            node = stack.pop()
            tmp.next = node
            tmp = tmp.next
        tmp.next = None
        return cur.next
```

* 旋转k个节点

```python
class Solution:
    def rotateRight(self, head: ListNode, k: int) -> ListNode:
        if head is None or head.next is None: return head
        cur = head
        num = 0
        while cur:
            cur = cur.next
            num += 1
        first = second = head
        k = k % num
        for i in range(k,0,-1):
            first = first.next
        while first.next:
            first = first.next
            second = second.next
        first.next = head 
        head = second.next
        second.next = None
        return head
```

* 反转m-n节点

```python
class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        stack = []
        l = n - m + 1

        origin = prev = ListNode(-1)
        prev.next = head
        while head:
            m -= 1
            if m == 0:
                while l > 0:
                    stack.append(head)
                    head = head.next
                    l -= 1
                while stack:
                    prev.next = stack.pop()
                    prev = prev.next
                prev.next = head
                break
            prev = head
            head = head.next
        return origin.next
```

