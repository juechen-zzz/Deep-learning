# 特殊数字

## 1 快乐树

* 一个快乐数是由以下过程定义的数字：
	* 从任何正整数开始，用该数字的平方和代替该数字，然后重复该过程，直到该数字等于1（它将停留在该位置）
	* 否则它就会循环在不包含1的循环中无休止地循环。以1结尾的那些数字是快乐数字。

```python
class Solution:
    def isHappy(self, n: int) -> bool:
        visited = set()
        while n != 1 and n not in visited:
            visited.add(n)
            nxt = 0
            while n != 0:
                nxt += (n % 10) ** 2
                n //= 10
            n = nxt
        return n == 1
```



## 2 素数

* 计算素数

```python
class Solution:
    def countPrimes(self, n: int) -> int:
        if n < 2: return 0
        d = [1] * n
        d[0] = d[1] = 0
        for i in range(2, int(n**0.5)+1):
            if d[i]:
                d[i*i:n:i] = [0] * ((n-1-i*i) // i + 1)
        return sum(d)
```



## 3 排列组合

* 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合

	```python
	class Solution:
	    def combinationSum(self, candidates, target):
	      # 该函数返回一个类似字典的对象,默认为None。使用list作第一个参数，可以很容易将键-值对序列转换为列表字典
	        dp = [[] for _ in range(target+1)]
	        for val in candidates:
	            for j in range(val, target + 1):
	                if j - val == 0:
	                    dp[j].append([val])
	                else:
	                    for _list in dp[j-val]:
	                        l = _list + [val]
	                        dp[j].append(l)
	        return dp[target]
	```

* 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合，每个数字在每个组合中只能使用一次

	```python
	class Solution:
	    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
	        dp = [[] for _ in range(target+1)]
	        for val in candidates:
	            for i in reversed(range(val,target+1)):     # 返回一个反转的迭代器，也就从这和39题区别开
	                if i==val:
	                    dp[i].append([val])
	                else:
	                    for _list in dp[i-val]:
	                        l = _list + [val]
	                        dp[i].append(l)
	                    
	        # dp[-1]: [[6], [1, 5], [1, 5]], 然后排除重复的组合（同一数字在数组中多次出现的情况）
	        res = []
	        for i in dp[-1]:
	            if sorted(i) not in res:
	                res.append(sorted(i))
	        return res
	```

* 从1-9中取k个数和为n，每个数字在组合中只能用一次

	```python
	class Solution:
	    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
	        res = []
	        
	        def DFS(num, k, n, cur_sum, tmp):
	            if len(tmp) == k and cur_sum == n:
	                res.append(tmp[:])      
	                return
	            for i in range(num, 10):
	                if cur_sum + i <= n and len(tmp) < k:
	                    tmp.append(i)
	                    cur_sum += i
	                    DFS(i+1, k, n, cur_sum, tmp)
	                    tmp.pop()
	                    cur_sum -= i
	                    
	        DFS(1, k, n, 0, [])
	        return res
	```

* 全排列

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        if len(nums) <= 1: return [nums]
        res = []
        for idx, num in enumerate(nums):
            res_nums = nums[:idx] + nums[idx + 1:]  # 确定剩余元素
            for j in self.permute(res_nums):  
                res.append([num] + j)
        return res
```

* 全排列（不含重复）

```python
class Solution:
    def back_track(self, nums, temp, res_all):
            if len(nums)==0: res_all.append(temp)
            for i in range(len(nums)):
                if  i>0 and nums[i]==nums[i-1]: 
                    continue
                else:
                    self.back_track(nums[:i]+nums[i+1:],temp+[nums[i]], res_all)  
    
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:     
        temp=[]
        res_all=[]
        nums.sort()
        self.back_track(nums, temp, res_all)
        return res_all
```

* 所有子数列

```python
class Solution:
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """

        self.re_num=[]
        
        def DFS(nums,n):
            if len(n)>=0:
                self.re_num.append(n)
            for i in range(len(nums)):
                DFS(nums[i+1:],n+[nums[i]])

        DFS(nums,[])
        return self.re_num
```

* 所有子数列（去重）

```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = last = [[]]
        nums.sort()
        for ind, n in enumerate(nums):
            # use it or lose
            last = [s + [n] for s in (res if ind == 0 or nums[ind - 1] != nums[ind] else last)]
            res += last
        
        return res
```



## 4 丑数

* 判断是否为丑数，数字的因子只有2 3 5

	```python
	class Solution:
	    def isUgly(self, num: int) -> bool:
	        while num > 1 and (num % 2 == 0 or num % 3 == 0 or num % 5 == 0):
	            if num % 2 == 0: num /= 2
	            if num % 3 == 0: num /= 3
	            if num % 5 == 0: num /= 5
	        return num == 1
	```

* 返回第n个丑数

	```python
	class Solution:
	    def nthUglyNumber(self, n: int) -> int:
	        dp = [1 for _ in range(n)]
	        # 三指针初始化
	        i2, i3, i5 = 0, 0, 0
	        for i in range(1,n):
	            min_val = min(dp[i2]*2,dp[i3]*3,dp[i5]*5)
	            dp[i] = min_val
	            # 找出哪个指针对应的数造出了现在这个最小值，将指针前移一位
	            if dp[i2]*2 == min_val:
	                i2 += 1
	            if dp[i3]*3 == min_val:
	                i3 += 1
	            if dp[i5]*5 == min_val:
	                i5 += 1
	        return dp[-1]
	```

	

## 5 和

* 三数之和

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        length = len(nums)
        for i in range(length-2):
            if nums[i] > 0: break
            if i > 0 and nums[i] == nums[i-1]: continue
            
            l, r = i+1, length-1
            while l < r:
                total = nums[i] + nums[l] + nums[r]
                if total < 0:
                    l += 1
                elif total > 0:
                    r -= 1
                else:
                    res.append([nums[i], nums[l], nums[r]])
                    while l < r and nums[l] == nums[l+1]:
                        l += 1
                    while l < r and nums[r] == nums[r-1]:
                        r -= 1
                    l += 1
                    r -= 1
        return res
```

* 三数最近和

```python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        ans = float('inf')      # 无穷大
        for i in range(len(nums)-2):
            l = i + 1
            r = len(nums) - 1
            while l < r:
                total = nums[i] + nums[l] + nums[r]
                if total == target: return target
                elif total > target: r -= 1
                else: l += 1
                if abs(total - target) < abs(ans - target):
                    ans = total
        return ans
```

* 四数之和

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        ans = []
        for i in range(len(nums)-3):
            if i > 0 and nums[i]==nums[i-1]: continue
            for j in range(i+1, len(nums)-2):
                if j > i+1 and nums[j] == nums[j-1]: continue
                l = j + 1
                r = len(nums) - 1
                while l < r:
                    total = nums[i] + nums[j] + nums[l] + nums[r]
                    if total > target: r -= 1
                    elif total < target: l += 1
                    else: 
                        ans.append([nums[i], nums[j], nums[l], nums[r]])
                        while l < r and nums[l] == nums[l+1]: l += 1
                        while l < r and nums[r] == nums[r-1]: r -= 1
                        l += 1
                        r -= 1
        return ans
```



## 6 排序问题

* 下一组排序

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        index = len(nums)-1
        while index >= 1:                       # 从后往前找递减序列
            if nums[index-1] >= nums[index]:
                index -= 1
            else:
                break
        
        if index >= 1:                          # 递减序列断开的位置如果不为0，则需要改动，否则是纯递减，直接排序即可
            l = index - 1
            r = len(nums) - 1
            while nums[r] <= nums[l]:
                r -= 1
            nums[l], nums[r] = nums[r], nums[l]
            nums[index:] = sorted(nums[index:])
        else:
            nums.sort()
```

