# String

## 1 分割

* 将字符串分割成无重复的子串，求最多能分成多少个

```python
class Solution:
    def __init__(self):
        self.ans = 1
        self.dic = []
    
    def maxUniqueSplit(self, s: str) -> int:
        self.helper(0, s)
        return self.ans
    
    def helper(self, index, s):
        if index == len(s): self.ans = max(self.ans, len(self.dic))
        for i in range(index, len(s)):
            if s[index: i+1] not in self.dic:
                self.dic.append(s[index: i+1])
                self.helper(i+1, s)
                self.dic.pop()
        
```

* 将字符串分割，看能否分成的所有子串都在一个给定字典中

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [False] * (n+1)
        dp[0] = True
        
        for i in range(n):
            for j in range(i+1, n+1):
                if dp[i] and s[i:j] in wordDict:
                    dp[j] = True
        return dp[-1]
```



## 2 字符串比较

* 同构字符串

```python
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        d1, d2 = {}, {}
        for a, b in zip(s, t):
            if (a in d1 and d1[a] != b) or (b in d2 and d2[b] != a):
                return False
            d1[a], d2[b] = b, a
        return True
```

* 是否为相同字母不同排序

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t): return False
        return collections.Counter(s) == collections.Counter(t)
```

* 字符串匹配，有特殊字符（万能）

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        s_len, p_len = len(s), len(p)
        if p_len == 0: return s_len == 0

        # 首先判断len(p)>1 and p[1]=="*"，如果是的话，说明*在p的第二位，我们就要判断s[0]和p[0]能否匹配，
        # 如果可以匹配的话，我们继续判断isMatch(s[1:], p)（也就是*匹配了一次，我们会继续使用.*或者?*去参与比较），
        # 同时需要判断isMatch(s,p[2:])是不是成立（也就是*表示匹配0次）
        if p_len > 1 and p[1] == "*":          # return 只有两种情况
            return self.isMatch(s, p[2:]) or (s_len != 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))
        # 如果*不在p的第二位，我们就要判断s[0]和p[0]能否匹配
        else:
            return s_len != 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p[1:]) 
```

* 最长公共前缀

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs: return ""
        elif len(strs) == 1: return strs[0]
        else:
            min_len = min(len(s) for s in strs)
            index = 0
            while index < min_len:
                ch = strs[0][index]
                for i, c in enumerate(strs):
                    if c[index] != ch:
                        return strs[0][:index]
                index += 1
            return strs[0][:index]
```



## 3 子串

* 给定一个字符串，返回其中无重复最大子串的长度

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if len(s) == 0 or len(s) == 1: return len(s)
        
        max_len = 1
        index = 0
        substr = {}
        for k, v in enumerate(s):
            # 字典中查找的是键（key）
            if v in substr and index <= substr[v]:
                index = substr[v] + 1
            else:
                max_len = max(max_len, k-index+1)
            substr[v] = k
        return max_len
```

* 给定字符串，返回最大回文子串

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        p = ''
        index = 0
        while index < len(s):
            l = r = index
            while l-1 >= 0 and s[l] == s[l-1]:
                l -= 1
            while r+1 < len(s) and s[r] == s[r+1]:
                r += 1
            index = r + 1
            while l >= 0 and r < len(s) and s[l] == s[r]:
                l, r = l-1, r+1
            
            p = max(p, s[l+1: r], key = lambda x: len(x))
        return p
```



## 4 匹配

* 括号匹配

```python
class Solution:
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        pre_dict = {')': '(', ']': '[', '}': '{'}
        stack = []
        for i in s:
            if i in pre_dict.values():  # 表明i为左括号，入栈
                stack.append(i)
        # i为右括号，若此时栈空(not stack)或者与出栈的不匹配则匹配出错 ，return False
            elif not stack or pre_dict[i] != stack.pop():
                return False
        return not stack  # 若结束时栈空则return True,反之return False
```

* 对称括号生成

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        ans = []

        def backtrack(s = '', l = 0, r = 0):
            if len(s) == 2 * n:
                ans.append(s)
                return
            if l < n:
                backtrack(s+'(', l+1, r)
            if r < l:
                backtrack(s+')', l, r+1)
        
        backtrack()
        return ans
```

* 最大对称括号子串长度

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        dp = [0 for _ in range(len(s)+1)]
        for i in range(1, len(s)):
            if s[i] == ')' and i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':
                dp[i] = dp[i-1] + 2
                if i-dp[i-1]-2 >= 0:
                    dp[i] += dp[i-dp[i-1]-2]
        return max(dp)
```

