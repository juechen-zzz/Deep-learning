# 数据结构和算法笔记



* 数据结构是为算法服务的，算法要作用在特定的数据结构之上。

![img](https://static001.geekbang.org/resource/image/91/a7/913e0ababe43a2d57267df5c5f0832a7.jpg)

* 10个数据结构：**数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树**。
* 10个算法：**递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法**。
* 数据结构是“一组数据的存储结构”，算法是“操作数据的一种方法”。



## 1. 复杂度分析

- 事后统计法缺点：依赖环境，受数据规模影响。

```java
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

结论：所有代码的执行时间T(n)与每行代码的执行次数成正比。

```java
 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```

总执行时间为：
$$
2n^2+2n+3
$$

### 1.1 大O公式

$$
T(n)=O(f(n))
$$

第一个例子T(n)=O(2n+2),第二个例子T(n)=O(2n^2+2n+3)。

* 大O时间复杂度并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，也叫渐进时间复杂度，简称时间复杂度。

* 当n很大时，公式中的低阶、常量、系数并不左右增长趋势，只需记录一个最大量级。

* 分析方法：

  * 只关注循环执行次数最多的一段代码。

  * 加法法则：总复杂度等于量级最大的那段代码的复杂度。

  * 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

    ```java
    int cal(int n) {
       int ret = 0; 
       int i = 1;
       for (; i < n; ++i) {
         ret = ret + f(i);
       } 
     } 
     
     int f(int n) {
      int sum = 0;
      int i = 1;
      for (; i < n; ++i) {
        sum = sum + i;
      } 
      return sum;
     }
    ```

### 1.2 复杂度量级

![1554084629522](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554084629522.png)

* 分为**多项式量级**和**非多项式量级**。其中，非多项式量级只有2个：**指数**和**阶乘**。

* 当n越来越大时，非多项式量级算法的执行时间会急剧增加。所以，这是一种低效的算法。

  * **O(1)**:只是常量级时间复杂度的一种表示方法，并不是只执行了一行代码。一般情况下，只要算法中不存在**循环**和**递归**，时间复杂度就是O(1)。

  * **O(logn)**、**O(nlogn)**:

    ```java
     i=1;
     while (i <= n)  {
       i = i * 2;
     }
    ```

    可以看出，变量i的值从1开始，每循环一次就乘以2，实际上就是一个等比数列。![1554085156357](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554085156357.png)

    所以，**x**就是代码执行的次数，时间复杂度为O(log2n)。

    由于对数存在**换底公式**，在采用大O标记复杂度的时候，可以忽略系数。**O(Cf(n)) = O(f(n))**，所以，在对数阶时间复杂度的表示方法中，忽略底数。

  * **O(m+n)**、**O(m*n)**：代码的复杂度由**两个数据**的规模来决定。

    ```java
    int cal(int m, int n) {
      int sum_1 = 0;
      int i = 1;
      for (; i < m; ++i) {
        sum_1 = sum_1 + i;
      }
    
      int sum_2 = 0;
      int j = 1;
      for (; j < n; ++j) {
        sum_2 = sum_2 + j;
      }
    
      return sum_1 + sum_2;
    }
    ```

    可以看出，m和n是两个数据规模，我们事先无法知道m和n谁的量级大，所以，上面代码的时间复杂度就是O(m+n)。**此时，加法法则就不能用了，改为T1(m) + T2(n) = O(f(m) + g(n))；乘法法则依旧有效，T1(m)*T2(n) = O(f(m) * f(n))**。

### 1.3 空间复杂度分析

* 时间复杂度的全称是渐进时间复杂度，表示算法的**执行时间与数据规模**之间的增长关系。
* 空间复杂度的全称是渐进空间复杂度，表示算法的**存储空间与数据规模**之间的增长关系。

```java
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

在第二行代码中，我们申请了一个空间存储变量i，但是它是常量阶的，与数据规模n没有关系。第三行申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以空间复杂度为O(n)。

![1554087085121](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554087085121.png)

### 1.4 最好、最坏情况时间复杂度

```java
int find(int[] array, int n n int x ){
    int i = 0;
    int pos =-1;
    for(; i < n;++i){
        if (array[i] == x) pos =i;
    }
    return pos;
}

// 优化代码
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

* 最好情况时间复杂度：在**最理想**的情况下，执行这段代码的时间复杂度
* 最坏情况时间复杂度：在**最糟糕**的情况下，执行指端代码的时间复杂度

### 1.5 平均时间复杂度

* 要查找的变量x在数组中的位置，有n+1种情况：在数组的**0~n-1位置**中和**不在数组**中。我们把每种情况下，查找需要遍历的元素个数累加起来，再除以n+1：

  ![1554166946205](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554166946205.png)

* 考虑各种情况的概率：

![1554167091827](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554167091827.png)

​	这个值就是概率论中的**加权平均值**，也称为**期望值**。

### 1.6 均摊时间复杂度

* 分析方法：**摊还分析**。

```java
int[] array = new int[n];
int count = 0;

void insert(int val){
    if (count == array.length){
        int sum = 0 ;
        for (int i = 0 ; i < array.length; ++i){
            sum = sum + array[i];
        }
        array[0] = sum;
        count = 1;
    }
    array[count] = val;
    ++count;
}
```

* 最好时间复杂度为O（1），最坏为O（n），平均为O（1）。

![1554169189360](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554169189360.png)

* find()和insert()的区别
  * find()在极端情况下，复杂度为O(1)，insert()在大多数情况下，复杂度为O(1)。
  * 对于 insert() 函数来说，O(1) 时间复杂度的插入和O(n)时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个O(n)插入后，紧跟着n-1个O(1)的插入操作，循环往复。

* **大致思路**：每一次 O(n) 的插入操作，都会跟着n-1次O(1)的插入操作，把耗时多的均摊到接下来的耗时少的n-1次操作上。

* 课后题：

  ```java
  // 全局变量，大小为 10 的数组 array，长度 len，下标 i。
  int array[] = new int[10]; 
  int len = 10;
  int i = 0;
  
  // 往数组中添加一个元素
  void add(int element) {
     if (i >= len) { // 数组空间不够了
       // 重新申请一个 2 倍大小的数组空间
       int new_array[] = new int[len*2];
       // 把原来 array 数组中的数据依次 copy 到 new_array
       for (int j = 0; j < len; ++j) {
         new_array[j] = array[j];
       }
       // new_array 复制给 array，array 现在大小就是 2 倍 len 了
       array = new_array;
       len = 2 * len;
     }
     // 将 element 放到下标为 i 的位置，下标 i 加一
     array[i] = element;
     ++i;
  }
  ```

  该算法的最好情况时间复杂度(best case time complexity)为O(1);
  最坏情况时间复杂度(worst case time complexity)为O(n);
  平均情况时间复杂度(average case time complexity),
  **第一种计算方式**: (1+1+...+1+n)/(n+1) = 2n/(n+1) 【注: 式子中1+1+...+1中有n个1】,所以平均复杂度为O(1);
  **第二种计算方式**(加权平均法，又称期望): 1*(1/n+1)+1*(1/n+1)+...+1*(1/n+1)+n*(1/(n+1))=1，所以加权平均时间复杂度为O(1);
  **第三种计算方式**(均摊时间复杂度): 前n个操作复杂度都是O(1)，第n+1次操作的复杂度是O(n)，所以把最后一次的复杂度分摊到前n次上，那么均摊下来每次操作的复杂度为O(1)



## 2. 数组

* 数组是一种**线性表**数据结构，它用一组**连续的**内存空间，来存储一组具有**相同类型**的数据。

  * 线性表：数据排成像一条线一样的结构，每个线性表的数据最多只有前后两个方向。![1554597716134](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554597716134.png)
  * 非线性表：数据之间不是简单的前后关系。![1554597749533](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554597749533.png)

* 数组与链表的区别：

  链表适合插入、删除；

  数组适合查找，支持**随机访问**，根据下标随机访问的时间复杂度为O(1)。

### 2.1 删除操作

​	![1554598367107](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554598367107.png)

​	为了避免d e f g h会被搬移3次，我们可以先记录下已经删除的数据。每次的删除操作**不是真正的搬移数据，只是记录数据已经被删除**。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大量减少了操作导致的数据搬移。

* 以上就是**JVM标记清除垃圾回收算法**的核心思想。

### 2.2 数组访问越界

* 当数组长度确定，在执行循环时，访问了一个超出数组长度的内存地址，就会产生无限循环。

### 2.3 容器

* Java中的ArrayList，C++ STL中的vector
* ArratList优势：可以**将很多数组操作的细节封装**起来；支持**动态扩容**。
* ![1554599129874](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554599129874.png)

### 2.4 下标

* 下标的最确切定义是**偏移**，如果用a表示数组的首地址，a[0]就是偏移为0的位置。



## 3. 链表

* 缓存淘汰策略：
  * 先进先出策略FIFO（first in , first out）
  * 最少使用策略LFU（least frequently used）
  * 最近最少使用策略LRU（least recently used）

### 3.1 数组和链表的区别

* **底层存储结构角度**：

  * 数组需要一组**连续的内存空间**来存储，对内存的要求较高。
  * 链表不需要连续的内存空间，通过“**指针**”将一组**零散的内存块**串联起来使用。

  ![1554683655055](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554683655055.png)

* **数据查找、插入和删除角度**：

  * 数组进行这些操作需要进行大量的数据搬移，时间复杂度为**O(n)**。
  * 链表只需要考虑相邻结点的指针改变，时间复杂度为**O(1)**。

  ![1554684153991](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554684153991.png)

* **随机访问角度**：

  * 数组通过首地址和下标，用寻址公式直接计算内存地址，时间复杂度**O(1)**。
  * 链表需要通过指针一个结点一个结点的进行遍历，性能弱于数组，时间复杂度为**O(n)**。

* **内存角度**：

  * 数组可以借助CPU的**缓存**机制，预读数据，访问效率高；而链表并不是连续存储，不好有效预读。
  * 数组的**缺点**是大小固定；链表本身没有大小限制，天然支持动态扩容。

### 3.2 单链表

* 链表通过指针将一组零散的内存块串联在一起，将内存块称为链表的**结点**。每个链表的结点除了存储数据之外，还需要记录下一个结点的地址，记录下个地址的指针称为**后继指针next**。
* 第一个结点称为**头结点**，最后一个为**尾结点**。头结点记录链表基地址，尾结点指针指向**空地址NULL**。

### 3.3 循环链表和双向链表

* 循环链表是一种特殊的单链表，尾结点指针指向头结点。
* 双向链表支持两个方向，一个**后继指针next**，一个**前驱指针prev**。占用更多空间，但是支持双向遍历。

![1554685734598](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554685734598.png)

* 链表删除操作：
  * 删除结点中“值等于给定值”的结点，都需要遍历，时间复杂度为O(n)。
  * 删除指定指针指向的结点。**单链表O(n)，双向链表O(1)**。
* 双向链表是一种**用空间换时间**的思维。

### 3.4 LRU缓存淘汰算法

* 时间复杂度O(n)

![1554686272323](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554686272323.png)

### 3.5 CPU缓存机制

* CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:**为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入**。
* 对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。  

### 3.6 链表代码技巧

* 理解指针或者引用的含义

  * C语言用指针，Java、Python用引用。
  * **将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者说，指针中存储了这个变量的内存地址，指向了这个变量。**

  ```C
  p->next = q						#p结点中的next指针存储了q结点的内存地址
  p->next = p->next->next			#p结点中的next指针存储了p结点的下下一个结点的内存地址
  ```

* 警惕指针丢失和内存泄漏

  * 插入结点时，注意操作的顺序
  * 删除结点时，记得手动释放内存空间
    * C语言中，内存管理由程序员负责
    * Java语言中，虚拟机自动管理内存

* 利用哨兵简化实现难度

  * 有哨兵结点的叫**带头链表**

![1554771686781](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554771686781.png)

* 注意边界条件处理（空链表，1个结点，2个结点，头尾结点）

### 3.7 5个常见链表操作

* **单链表反转**
* **链表中环的检测**
* **两个有序的链表合并**
* **删除链表倒数第n个结点**
* **求链表的中间结点**





