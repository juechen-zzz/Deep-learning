数据结构和算法笔记



* 数据结构是为算法服务的，算法要作用在特定的数据结构之上。

![img](https://static001.geekbang.org/resource/image/91/a7/913e0ababe43a2d57267df5c5f0832a7.jpg)

* 10个数据结构：**数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树**。
* 10个算法：**递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法**。
* 数据结构是“一组数据的存储结构”，算法是“操作数据的一种方法”。



## 1. 复杂度分析

- 事后统计法缺点：依赖环境，受数据规模影响。

```java
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

结论：所有代码的执行时间T(n)与每行代码的执行次数成正比。

```java
 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```

总执行时间为：
$$
2n^2+2n+3
$$

### 1.1 大O公式

$$
T(n)=O(f(n))
$$

第一个例子T(n)=O(2n+2),第二个例子T(n)=O(2n^2+2n+3)。

* 大O时间复杂度并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，也叫渐进时间复杂度，简称时间复杂度。

* 当n很大时，公式中的低阶、常量、系数并不左右增长趋势，只需记录一个最大量级。

* 分析方法：

  * 只关注循环执行次数最多的一段代码。

  * 加法法则：总复杂度等于量级最大的那段代码的复杂度。

  * 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

    ```java
    int cal(int n) {
       int ret = 0; 
       int i = 1;
       for (; i < n; ++i) {
         ret = ret + f(i);
       } 
     } 
     
     int f(int n) {
      int sum = 0;
      int i = 1;
      for (; i < n; ++i) {
        sum = sum + i;
      } 
      return sum;
     }
    ```

### 1.2 复杂度量级

![1554084629522](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554084629522.png)

* 分为**多项式量级**和**非多项式量级**。其中，非多项式量级只有2个：**指数**和**阶乘**。

* 当n越来越大时，非多项式量级算法的执行时间会急剧增加。所以，这是一种低效的算法。

  * **O(1)**:只是常量级时间复杂度的一种表示方法，并不是只执行了一行代码。一般情况下，只要算法中不存在**循环**和**递归**，时间复杂度就是O(1)。

  * **O(logn)**、**O(nlogn)**:

    ```java
     i=1;
     while (i <= n)  {
       i = i * 2;
     }
    ```

    可以看出，变量i的值从1开始，每循环一次就乘以2，实际上就是一个等比数列。![1554085156357](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554085156357.png)

    所以，**x**就是代码执行的次数，时间复杂度为O(log2n)。

    由于对数存在**换底公式**，在采用大O标记复杂度的时候，可以忽略系数。**O(Cf(n)) = O(f(n))**，所以，在对数阶时间复杂度的表示方法中，忽略底数。

  * **O(m+n)**、**O(m*n)**：代码的复杂度由**两个数据**的规模来决定。

    ```java
    int cal(int m, int n) {
      int sum_1 = 0;
      int i = 1;
      for (; i < m; ++i) {
        sum_1 = sum_1 + i;
      }
    
      int sum_2 = 0;
      int j = 1;
      for (; j < n; ++j) {
        sum_2 = sum_2 + j;
      }
    
      return sum_1 + sum_2;
    }
    ```

    可以看出，m和n是两个数据规模，我们事先无法知道m和n谁的量级大，所以，上面代码的时间复杂度就是O(m+n)。**此时，加法法则就不能用了，改为T1(m) + T2(n) = O(f(m) + g(n))；乘法法则依旧有效，T1(m)*T2(n) = O(f(m) * f(n))**。

### 1.3 空间复杂度分析

* 时间复杂度的全称是渐进时间复杂度，表示算法的**执行时间与数据规模**之间的增长关系。
* 空间复杂度的全称是渐进空间复杂度，表示算法的**存储空间与数据规模**之间的增长关系。

```java
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

在第二行代码中，我们申请了一个空间存储变量i，但是它是常量阶的，与数据规模n没有关系。第三行申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以空间复杂度为O(n)。

![1554087085121](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554087085121.png)

### 1.4 最好、最坏情况时间复杂度

```java
int find(int[] array, int n n int x ){
    int i = 0;
    int pos =-1;
    for(; i < n;++i){
        if (array[i] == x) pos =i;
    }
    return pos;
}

// 优化代码
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

* 最好情况时间复杂度：在**最理想**的情况下，执行这段代码的时间复杂度
* 最坏情况时间复杂度：在**最糟糕**的情况下，执行指端代码的时间复杂度

### 1.5 平均时间复杂度

* 要查找的变量x在数组中的位置，有n+1种情况：在数组的**0~n-1位置**中和**不在数组**中。我们把每种情况下，查找需要遍历的元素个数累加起来，再除以n+1：

  ![1554166946205](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554166946205.png)

* 考虑各种情况的概率：

![1554167091827](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554167091827.png)

​	这个值就是概率论中的**加权平均值**，也称为**期望值**。

### 1.6 均摊时间复杂度

* 分析方法：**摊还分析**。

```java
int[] array = new int[n];
int count = 0;

void insert(int val){
    if (count == array.length){
        int sum = 0 ;
        for (int i = 0 ; i < array.length; ++i){
            sum = sum + array[i];
        }
        array[0] = sum;
        count = 1;
    }
    array[count] = val;
    ++count;
}
```

* 最好时间复杂度为O（1），最坏为O（n），平均为O（1）。

![1554169189360](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554169189360.png)

* find()和insert()的区别
  * find()在极端情况下，复杂度为O(1)，insert()在大多数情况下，复杂度为O(1)。
  * 对于 insert() 函数来说，O(1) 时间复杂度的插入和O(n)时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个O(n)插入后，紧跟着n-1个O(1)的插入操作，循环往复。

* **大致思路**：每一次 O(n) 的插入操作，都会跟着n-1次O(1)的插入操作，把耗时多的均摊到接下来的耗时少的n-1次操作上。

* 课后题：

  ```java
  // 全局变量，大小为 10 的数组 array，长度 len，下标 i。
  int array[] = new int[10]; 
  int len = 10;
  int i = 0;
  
  // 往数组中添加一个元素
  void add(int element) {
     if (i >= len) { // 数组空间不够了
       // 重新申请一个 2 倍大小的数组空间
       int new_array[] = new int[len*2];
       // 把原来 array 数组中的数据依次 copy 到 new_array
       for (int j = 0; j < len; ++j) {
         new_array[j] = array[j];
       }
       // new_array 复制给 array，array 现在大小就是 2 倍 len 了
       array = new_array;
       len = 2 * len;
     }
     // 将 element 放到下标为 i 的位置，下标 i 加一
     array[i] = element;
     ++i;
  }
  ```

  该算法的最好情况时间复杂度(best case time complexity)为O(1);
  最坏情况时间复杂度(worst case time complexity)为O(n);
  平均情况时间复杂度(average case time complexity),
  **第一种计算方式**: (1+1+...+1+n)/(n+1) = 2n/(n+1) 【注: 式子中1+1+...+1中有n个1】,所以平均复杂度为O(1);
  **第二种计算方式**(加权平均法，又称期望): 1*(1/n+1)+1*(1/n+1)+...+1*(1/n+1)+n*(1/(n+1))=1，所以加权平均时间复杂度为O(1);
  **第三种计算方式**(均摊时间复杂度): 前n个操作复杂度都是O(1)，第n+1次操作的复杂度是O(n)，所以把最后一次的复杂度分摊到前n次上，那么均摊下来每次操作的复杂度为O(1)



## 2. 数组

* 数组是一种**线性表**数据结构，它用一组**连续的**内存空间，来存储一组具有**相同类型**的数据。

  * 线性表：数据排成像一条线一样的结构，每个线性表的数据最多只有前后两个方向。![1554597716134](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554597716134.png)
  * 非线性表：数据之间不是简单的前后关系。![1554597749533](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554597749533.png)

* 数组与链表的区别：

  链表适合插入、删除；

  数组适合查找，支持**随机访问**，根据下标随机访问的时间复杂度为O(1)。

### 2.1 删除操作

​	![1554598367107](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554598367107.png)

​	为了避免d e f g h会被搬移3次，我们可以先记录下已经删除的数据。每次的删除操作**不是真正的搬移数据，只是记录数据已经被删除**。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大量减少了操作导致的数据搬移。

* 以上就是**JVM标记清除垃圾回收算法**的核心思想。

### 2.2 数组访问越界

* 当数组长度确定，在执行循环时，访问了一个超出数组长度的内存地址，就会产生无限循环。

### 2.3 容器

* Java中的ArrayList，C++ STL中的vector
* ArratList优势：可以**将很多数组操作的细节封装**起来；支持**动态扩容**。
* ![1554599129874](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554599129874.png)

### 2.4 下标

* 下标的最确切定义是**偏移**，如果用a表示数组的首地址，a[0]就是偏移为0的位置。



## 3. 链表

* 缓存淘汰策略：
  * 先进先出策略FIFO（first in , first out）
  * 最少使用策略LFU（least frequently used）
  * 最近最少使用策略LRU（least recently used）

### 3.1 数组和链表的区别

* **底层存储结构角度**：

  * 数组需要一组**连续的内存空间**来存储，对内存的要求较高。
  * 链表不需要连续的内存空间，通过“**指针**”将一组**零散的内存块**串联起来使用。

  ![1554683655055](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554683655055.png)

* **数据查找、插入和删除角度**：

  * 数组进行这些操作需要进行大量的数据搬移，时间复杂度为**O(n)**。
  * 链表只需要考虑相邻结点的指针改变，时间复杂度为**O(1)**。

  ![1554684153991](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554684153991.png)

* **随机访问角度**：

  * 数组通过首地址和下标，用寻址公式直接计算内存地址，时间复杂度**O(1)**。
  * 链表需要通过指针一个结点一个结点的进行遍历，性能弱于数组，时间复杂度为**O(n)**。

* **内存角度**：

  * 数组可以借助CPU的**缓存**机制，预读数据，访问效率高；而链表并不是连续存储，不好有效预读。
  * 数组的**缺点**是大小固定；链表本身没有大小限制，天然支持动态扩容。

### 3.2 单链表

* 链表通过指针将一组零散的内存块串联在一起，将内存块称为链表的**结点**。每个链表的结点除了存储数据之外，还需要记录下一个结点的地址，记录下个地址的指针称为**后继指针next**。
* 第一个结点称为**头结点**，最后一个为**尾结点**。头结点记录链表基地址，尾结点指针指向**空地址NULL**。

### 3.3 循环链表和双向链表

* 循环链表是一种特殊的单链表，尾结点指针指向头结点。
* 双向链表支持两个方向，一个**后继指针next**，一个**前驱指针prev**。占用更多空间，但是支持双向遍历。

![1554685734598](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554685734598.png)

* 链表删除操作：
  * 删除结点中“值等于给定值”的结点，都需要遍历，时间复杂度为O(n)。
  * 删除指定指针指向的结点。**单链表O(n)，双向链表O(1)**。
* 双向链表是一种**用空间换时间**的思维。

### 3.4 LRU缓存淘汰算法

* 时间复杂度**O(n)**，**（在散列表可以继续优化）**

![1554686272323](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554686272323.png)

### 3.5 CPU缓存机制

* CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:**为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入**。
* 对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。  

### 3.6 链表代码技巧

* 理解指针或者引用的含义

  * C语言用指针，Java、Python用引用。
  * **将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者说，指针中存储了这个变量的内存地址，指向了这个变量。**

  ```C
  p->next = q						# p结点中的next指针存储了q结点的内存地址
  p->next = p->next->next			# p结点中的next指针存储了p结点的下下一个结点的内存地址
  ```

* 警惕指针丢失和内存泄漏

  * 插入结点时，注意操作的顺序
  * 删除结点时，记得手动释放内存空间
    * C语言中，内存管理由程序员负责
    * Java语言中，虚拟机自动管理内存

* 利用哨兵简化实现难度

  * 有哨兵结点的叫**带头链表**

![1554771686781](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554771686781.png)

* 注意边界条件处理（空链表，1个结点，2个结点，头尾结点）

### 3.7 5个常见链表操作

* **单链表反转**
* **链表中环的检测**
* **两个有序的链表合并**
* **删除链表倒数第n个结点**
* **求链表的中间结点**



## 4. 栈

### 4.1  栈的理解

* 一摞叠在一起的盘子，都是从下往上一个一个放，再从上往下一个一个拿。**后进者先出，先进者后出**。
* 从“操作特性”看，栈是一种**受限制的线性表**。
* 从功能上来说，数组和列表可以替代栈。但是，数组和列表暴露了太多的操作接口，使用时不太容易控制。

### 4.2 栈的实现

* 主要两个操作：**入栈**和**出栈**。
* 用数组实现的栈，叫做**顺序栈**；用链表实现的栈，叫做**链式栈**。
* 空间复杂度：在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度为O(1)。
* 时间复杂度：在入栈和出栈过程中，只涉及栈顶个别数据的操作，所以时间复杂度为O(1)。

### 4.3 支持动态扩容的栈

* 链式栈大小不受限，但是需要存储指针，比较耗内存。
* 与动态数组类似，当栈满了之后，申请一个更大的数组，将原来的数据搬移进去。

![1554855657795](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554855657795.png)

### 4.4 函数调用栈

```java
int main() {
   int a = 1; 
   int ret = 0;
   int res = 0;
   ret = add(3, 5);
   res = a + ret;
   printf("%d", res);
   reuturn 0;
}

int add(int x, int y) {
   int sum = 0;
   sum = x + y;
   return sum;
}
```

![1554856241146](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554856241146.png)

### 4.5 表达式求值

* 编译器通过两个栈来实现，一个保存操作数，一个保存运算符的栈。

* 从左到右遍历表达式，遇到数字直接压入栈，遇到运算符，则与运算符栈的栈顶元素比较。

  * 如果比运算符栈栈顶元素优先级高，就将当前运算符压入栈。
  * 如果比运算符栈栈顶元素优先级低，取出栈顶运算符，在从操作数栈取2个操作数，进行计算，把计算过后的结构压入操作数栈，继续比较。

  ![1554856599406](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554856599406.png)

### 4.6 应用

#### 4.6.1 括号匹配

* 用栈保存未匹配的左括号，从左往右扫描字符串。当扫描到左括号时，将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。若能匹配，则继续扫描，若不能，则为非法格式。

#### 4.6.2 浏览器的前进、后退

![1554856921934](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554856921934.png)



## 5. 队列

* 与栈理解相似，**先进者先出**，即为队列。
* 基本操作：**入队（enqueue）**和**出队（dequene）**
* 与栈相同，一种受限制的线性表shujujieg

### 5.1 顺序队列（数组实现）

```java
// 用数组实现的队列
public class ArrayQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head 表示队头下标，tail 表示队尾下标
  private int head = 0;
  private int tail = 0;

  // 申请一个大小为 capacity 的数组
  public ArrayQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }

  // 入队
  public boolean enqueue(String item) {
    // 如果 tail == n 表示队列已经满了
    if (tail == n) return false;
    items[tail] = item;
    ++tail;
    return true;
  }

  // 出队
  public String dequeue() {
    // 如果 head == tail 表示队列为空
    if (head == tail) return null;
    String ret = items[head];
    ++head;
    return ret;
  }
}

```

* 队列有2个指针，head指针和tail指针

![1554945553490](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554945553490.png)

* 数据搬移，集中到入队操作中

```java
   // 入队操作，将 item 放入队尾
  public boolean enqueue(String item) {
    // tail == n 表示队列末尾没有空间了
    if (tail == n) {
      // tail ==n && head==0，表示整个队列都占满了
      if (head == 0) return false;
      // 数据搬移
      for (int i = head; i < tail; ++i) {
        items[i-head] = items[i];
      }
      // 搬移完之后重新更新 head 和 tail
      tail -= head;
      head = 0;
    }
    
    items[tail] = item;
    ++tail;
    return true;
  }
```

当队列的tail指针移动到数组的最右边后，如果有新的数据入队，可以将head到tail之间的数据，整体搬移到数组中0到（tail - head）的位置

![1554945756028](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554945756028.png)

### 5.2 链式队列

![1554945827495](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554945827495.png)

### 5.3 循环队列

![1554946071091](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554946071091.png)

* 队空与队满的条件：
  * 对空的条件：**head == tail**
  * 队满的条件：**（tail +1）% n == head**

```java
public class CircularQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head 表示队头下标，tail 表示队尾下标
  private int head = 0;
  private int tail = 0;

  // 申请一个大小为 capacity 的数组
  public CircularQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }

  // 入队
  public boolean enqueue(String item) {
    // 队列满了
    if ((tail + 1) % n == head) return false;
    items[tail] = item;
    tail = (tail + 1) % n;
    return true;
  }

  // 出队
  public String dequeue() {
    // 如果 head == tail 表示队列为空
    if (head == tail) return null;
    String ret = items[head];
    head = (head + 1) % n;
    return ret;
  }
}

```

### 5.4 阻塞队列与并发队列

* 阻塞队列即在队列基础上增加了阻塞操作，类似于**生产者-消费者模型**。
* **线程安全**的队列称之为并发队列。

### 5.5 线程池调度

* 第一种方法：直接拒绝任务请求。
* 第二种方法：阻塞的处理方式：请求排队，有空闲线程时，继续处理。
  * 基于链表：可实现支持无限排队的无界队列，但可能导致请求处理的时间过长。
  * 基于数组：队列大小有限，请求超过队列大小时，接下来的请求会被拒绝。**应用较多**。



## 6. 排序

![1555117041238](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555117041238.png)

### 6.1 排序算法的执行效率

* 最好、最坏、平均时间复杂度
* 时间复杂度的系数、常数、低阶
* 比较次数和交换次数

### 6.2 排序算法特性

* **原地排序**：空间复杂度为O(1)的排序算法。

* **稳定性**：待排序的序列中存在值相同的元素，排序结束后，相等元素原有的先后顺序不变。

* 稳定排序算法：电商订单时间和金额问题：

  * 第一种，先按金额，在相同金额时按时间
  * 第二种，先按时间，然后用**稳定排序算法**按金额重新排序

  ![1555118585895](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555118585895.png)

### 6.3 冒泡排序

```java
// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```

* 冒泡排序只会操作相邻的两个元素，看是否满足大小要求，若不满足则交换元素。
* 举例：4,5,6,3,2,1
  * 第一次冒泡过程

![1555119225628](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555119225628.png)

![1555119255867](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555119255867.png)

* 当某次冒泡操作**没有数据交换**时，说明到达完全有序，即可以优化。

![1555119365870](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555119365870.png)

#### 6.3.1 三个问题

* 冒泡排序是**原地排序算法**：只需要数据交换，要常量级的临时空间，空间复杂度O(1)

* 是**稳定**的排序算法：当相邻两个元素大小不等时，不作交换

* 时间复杂度：

  * 最好：1次冒泡，**O(n)**

  * 最坏：n次冒泡，**O(n^2)**

  * 平均：**O(n^2)**

    * 有序度：a[i] <= a[j] ，i < j 
    * 逆序度：与有序度相反，**逆序度 = 满有序度 - 有序度**
    * 每交换一次，有序度加一。两个操作原子，**比较**和**交换**
      * 最坏情况：初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换
      * 最好情况：有序度为n*(n-1)/2，所以不需要交换
      * 取中间值：n*(n-1)/4

    ![1555119666688](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555119666688.png)

### 6.4 插入排序

```java
// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

* 将数组数据分为两个区间：**已排序区间**和**未排序区间**。
* 取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间顺序一直有序。

![1555120828565](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555120828565.png)

* 移动操作的次数固定，为**逆序度**。

![1555120869519](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555120869519.png)

#### 6.4.1 三个问题

* 插入排序是**原地排序算法**：不需要额外的存储空间，空间复杂度为O(1)
* 是**稳定的**排序算法：对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，保存原有的前后顺序不变
* 时间复杂度：
  * 最好：**O(n)**，从尾到头遍历已经有序的数据
  * 最坏：**O(n^2)**，数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据
  * 平均：**O(n^2)**，在数组中插入一个数据的平均时间复杂度为O(n)，循环执行n次

### 6.5 选择排序

* 分已排序区间和未排序区间，选择排序每次从未排序区间中找到最小的元素，将其放到已排序区间的**末尾**。

![1555121748881](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555121748881.png)

#### 6.5.1 三个问题

* 是**原地排序算法**，空间复杂度为O(1)
* 是**不稳定**的排序算法，举例：5,8,5,2,9
* 时间复杂度：
  * 最好：**O(n^2)**
  * 最坏：**O(n^2)**
  * 平均：**O(n^2)**

### 6.6 归并排序

* **核心思想**：若要排序一个数组，先把数组从中间分为前后两部分，然后对两部分分别排序，再合并在一起。

* 使用**分治思想**：分治是一种解决问题的处理思想，递归是一种编程技巧

  ![1555204106766](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555204106766.png)

  ```C
  // 归并排序算法, A 是数组，n 表示数组大小
  merge_sort(A, n) {
    merge_sort_c(A, 0, n-1)
  }
  
  // 递归调用函数
  merge_sort_c(A, p, r) {
    // 递归终止条件
    if p >= r  then return
  
    // 取 p 到 r 之间的中间位置 q
    q = (p+r) / 2
    // 分治递归
    merge_sort_c(A, p, q)
    merge_sort_c(A, q+1, r)
    // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]
    merge(A[p...r], A[p...q], A[q+1...r])	# 将已经有序的 A[p…q] 和 A[q+1…r] 合并成一个
  
  ```

* **merge合并函数思想：申请一个临时数组，用两个游标分别指向2部分的第一个元素，比较大小，小的放入临时数组，游标向后一位**。

  ​	![1555204292544](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555204292544.png)

  ```C
  merge(A[p...r], A[p...q], A[q+1...r]) {
    var i := p，j := q+1，k := 0 // 初始化变量 i, j, k
    var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组
    while i<=q AND j<=r do {
      if A[i] <= A[j] {
        tmp[k++] = A[i++] // i++ 等于 i:=i+1
      } else {
        tmp[k++] = A[j++]
      }
    }
    
    // 判断哪个子数组中有剩余的数据
    var start := i，end := q
    if j<=r then start := j, end:=r
    
    // 将剩余的数据拷贝到临时数组 tmp
    while start <= end do {
      tmp[k++] = A[start++]
    }
    
    // 将 tmp 中的数组拷贝回 A[p...r]
    for i:=0 to r-p do {
      A[p+i] = tmp[i]
    }
  }
  ```

#### 6.6.1 三个问题

* 归并排序是**稳定**的排序算法：合并的过程中，若遇见值相同的元素，先放前半部分。

* 时间复杂度：**O(nlogn)**

  ```C
  T(1) = C；   // n=1 时，只需要常量级的执行时间，所以表示为 C。
  T(n) = 2*T(n/2) + n； n>1
  ```

  一直推导下去，**T(n) = 2^kT(n/2^k)+kn**。当T(n/2^k)=T(1)时，将k值带入

  得到**T(n)=Cn+nlog2n**。

* 归并排序**不是**原地排序算法，空间复杂度为**O(n)**

### 6.7 快速排序

* **核心思想**：从排序数组中任选一个数据（一般默认最后一个）为分区点，遍历数据，比分区点小的放左边，比分区点大的放右边；再利用分治思想，直到区间缩小到1，就说明数据有序。
* **时间复杂度**：（假设每次1:9分）

![1556588838736](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556588838736.png)

* 使用**分治思想**

  ![1555208183499](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555208183499.png)

  ```C
  // 快速排序，A 是数组，n 表示数组的大小
  quick_sort(A, n) {
    quick_sort_c(A, 0, n-1)
  }
  // 快速排序递归函数，p,r 为下标
  quick_sort_c(A, p, r) {
    if p >= r then return
    
    q = partition(A, p, r) // 获取分区点
    quick_sort_c(A, p, q-1)
    quick_sort_c(A, q+1, r)
  }
  ```

* **partition（）分区函数思想：通过游标将数组分为两部分，每次从未处理区间取一个元素A[j]，若小于分区点，则将其加入已处理区间的尾部，也就是A[i]的位置。**

  ![1555208371953](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555208371953.png)

  ``` C
  partition(A, p, r) {
    pivot := A[r]
    i := p
    for j := p to r-1 do {
      if A[j] < pivot {
        swap A[i] with A[j]
        i := i+1
      }
    }
    swap A[i] with A[r]
    return i
  
  ```

### 6.7.1 三个问题

* 快排是一种**原地排序**算法。
* 快排是**不稳定**的。 举例：6,8,7,6,3,5,9,4
* 时间复杂度：
  * 最好：**O(nlogn)**
  * 最坏：**O(n^2)**
  * 平均：**O(nlogn)**

### 6.7.2 归并排序与快速排序的区别

![1555208652809](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555208652809.png)

* 归并排序的处理过程是**由下到上**的，先处理子问题，再合并。
* 快速排序的处理过程是**由上到下**的，先分区，在处理子问题。
* 归并排序虽然稳定，但是一个**非原地排序算法**。快排通过原地分区函数，可以实现**原地排序**，解决了归并排序占用太多内存的问题。

### 6.8 线性排序（桶、计数、基数）

#### 6.8.1 桶排序

* **核心思想**：将要排序的数据分到几个有序的桶中，每个桶中的数据单独进行排序，排序完成之后，再将每个桶内的数据按顺序取出，组成的序列就是有序的了。![1555289354832](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555289354832.png)
* 时间复杂度为**O(n)**
  * 如果要排序的数据有n个，均匀的分到m个桶中，每个桶中有k=n / m 个数据。
  * 每个桶内使用快速排序，时间复杂度为O(k * logk)
  * m个桶排序的时间复杂度为O(m * k * logk)
  * 当桶的数量m接近n时，logk是一个很小的常量，最终时间复杂度接近O(n)
* 桶排序比较适合在**外部排序**中，比如说硬盘内有10GB数据，内存只有1G，可以分成10个桶进行排序

#### 6.8.2 计数排序

* **核心思想**：当要排序的n个数据，所处的范围并不大的时候，可以每个值分为一个桶，举例：高考分数查询

* 时间复杂度：**O(n)**

* 计数排序算法：（假设8个考生，成绩放在A[8]数组中，成绩从0到5）

  * 使用大小为6的数组**C[6]**表示桶，存储**对应的考生个数**![1555291001887](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555291001887.png)

    * 对C[6]进行求和，C[k]中存储的**小于等于分数k的考生个数**![1555291061836](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555291061836.png)
    * 从后往前扫描数组A，假设第一个扫描到3，从C中取下标为3的值7，则包括自己在内，分数小于等于3的考生有7个，所有3是数组第7个元素（R中下标为6）；然后C[3]减一，变成6

    ![1555291229889](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555291229889.png)

    ```java
    // 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。
    public void countingSort(int[] a, int n) {
      if (n <= 1) return;
      
      // 查找数组中数据的范围
      int max = a[0];
      for (int i = 1; i < n; ++i) {
        if (max < a[i]) {
          max = a[i];
        }
      }
      
      int[] c = new int[max + 1]; // 申请一个计数数组 c，下标大小 [0,max]
      for (int i = 0; i <= max; ++i) {
        c[i] = 0;
      }
      
      // 计算每个元素的个数，放入 c 中
      for (int i = 0; i < n; ++i) {
        c[a[i]]++;
      }
      
      // 依次累加
      for (int i = 1; i <= max; ++i) {
        c[i] = c[i-1] + c[i];
      }
      
      // 临时数组 r，存储排序之后的结果
      int[] r = new int[n];
      
      // 计算排序的关键步骤，有点难理解
      for (int i = n - 1; i >= 0; --i) {
        int index = c[a[i]]-1;
        r[index] = a[i];
        c[a[i]]--;
      
      // 将结果拷贝给 a 数组
      for (int i = 0; i < n; ++i) {
        a[i] = r[i];
      }
    }
    ```

* 计数排序只适用于**数据范围不大**的场景中

### 6.8.3 基数排序

* 核心思想：先按照最后一位进行排序，然后再依次往前。

![1555291896898](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555291896898.png)

* 每位的排序算法必须是**稳定**的
* **基数排序对排序数据要求可以分割出独立的“位”来比较，而位与位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了**
* 时间复杂度为**O(n)**

### 6.9 排序优化

![1555375756285](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555375756285.png)

* 快排适合显示排序函数，但是，快排在最坏情况下时间复杂度为**O(n^2)**，主要原因是分区点选择不合理

#### 6.9.1 快排优化

1. 三数取中法：从区间的首、尾、中分别取出一个数，大小对比，取这三个数的中间值作为分区点
2. 随机法：每次从区间中随机取一个数，从概率的角度来说，一直取到最坏情况可能性不大，当然，最好情况也类似。

#### 6.9.2 qsort()

* qsort()会优先使用**归并排序**来排序输入数据，数据量小的情况下，可以用归并的空间复杂度O(n)
* 当排序数据量较大时，会改为快速排序，用三数取中法选择分区点
* 在快速排序的过程中，当要排序的区间中，元素个数小于等于4时，退化为插入排序。**在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn)执行时间长。**



## 7. 二分查找

* **二分思想：每次都与区间的中间数据对比大小，缩小查找区间的范围。直到找到要查找的元素，或者区间被缩小到0**
* low、high表示待查找区间的下标，mid表示待查找区间的中间元素下标![1555462054008](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555462054008.png)
* 时间复杂度：**O(logn)**![1555462476424](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555462476424.png)
  * 其中 n/2k=1 时，k 的值就是总共缩小的次数。
  * 经过了k次区间缩小操作，时间复杂度为O(k)，k=logn

### 7.1 二分查找的递归与非递归实现

* 有序数组中不存在重复元素时

  ```java
  public int bsearch(int[] a, int n, int value) {
    int low = 0;
    int high = n - 1;
  
    while (low <= high) {
      int mid = (low + high) / 2;
      if (a[mid] == value) {
        return mid;
      } else if (a[mid] < value) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
  
    return -1;
  }
  ```

  * 循环退出条件：**low <= high**
  * mid取值：mid = (low + high) / 2这种写法当low和high都很大的时候会发生溢出，改为mid = low +(high - low) / 2
  * low和high值的更新

* 用**递归**实现

  ```java
  // 二分查找的递归实现
  public int bsearch(int[] a, int n, int val) {
    return bsearchInternally(a, 0, n - 1, val);
  }
  
  private int bsearchInternally(int[] a, int low, int high, int value) {
    if (low > high) return -1;
  
    int mid =  low + ((high - low) >> 1);
    if (a[mid] == value) {
      return mid;
    } else if (a[mid] < value) {
      return bsearchInternally(a, mid+1, high, value);
    } else {
      return bsearchInternally(a, low, mid-1, value);
    }
  }
  ```

### 7.2 二分查找的局限性

* 首先，依赖顺序表结构，简单说就是数组
* 其次，二分查找针对的是有序数据
* 再次，数据量太小不适用
* 最后，数据量太大也不适用。因为依赖数组，数组在内存中需要连续的存储空间

### 7.3 二分查找的变形问题

* 查找第一个值等于给定值的元素

  ```java
  public int bsearch(int[] a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low <= high) {
      int mid =  low + ((high - low) >> 1);
      if (a[mid] > value) {
        high = mid - 1;
      } else if (a[mid] < value) {
        low = mid + 1;
      } else {
        if ((mid == 0) || (a[mid - 1] != value)) return mid;
        else high = mid - 1;
      }
    }
    return -1;
  }
  ```

* 查找最后一个值等于给定值的元素

  ```java
  public int bsearch(int[] a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low <= high) {
      int mid =  low + ((high - low) >> 1);
      if (a[mid] > value) {
        high = mid - 1;
      } else if (a[mid] < value) {
        low = mid + 1;
      } else {
        if ((mid == n - 1) || (a[mid + 1] != value)) return mid;
        else low = mid + 1;
      }
    }
    return -1;
  }
  ```

* 查找第一个大于等于给定值的元素

  ```java
  public int bsearch(int[] a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low <= high) {
      int mid =  low + ((high - low) >> 1);
      if (a[mid] >= value) {
        if ((mid == 0) || (a[mid - 1] < value)) return mid;
        else high = mid - 1;
      } 
      else {
        low = mid + 1;
      }
    }
    return -1;
  }
  ```

* 查找最后一个小于等于给定值的元素

  ```java
  public int bsearch(int[] a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low <= high) {
      int mid =  low + ((high - low) >> 1);
      if (a[mid] <= value) {
        if ((mid == n-1) || (a[mid + 1] > value)) return mid;
        else low = mid + 1;
      } 
      else {
        high = mid - 1;
      }
    }
    return -1;
  }
  ```



## 8.跳表

* 二分查找依赖于数组的**随机访问**特性，当数据是以**链表形式**存储的，则可以对链表稍加改造，就可以支持类似二分的查找算法，这种数据结构称之为跳表。

### 8.1 结构

* 将链表加上多级索引的结构，就是跳表![1555635321557](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555635321557.png)
* 跳表的**时间复杂度**分析**log(n)**
  * 假设跳表有h级索引，最高级的索引有2个结点，n / 2^h = 2, h = logn -1
  * 包含原始链表这一层，整个跳表的高度为logn
  * 若每一次遍历m个结点，则时间复杂度为O(m * logn)
    * 因为每一级索引中要遍历的最多为3个结点
    * m = 3
    * ![1555635894211](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555635894211.png)
* **缺点**：建立了很多级索引，以空间换时间
* 空间复杂度为O(n)

### 8.2 动态插入和删除

* 时间复杂度为**O(n)**
* ![1555637477144](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555637477144.png)
* 跳表是通过**随机函数**来维护前面提到的“平衡性![1555637533904](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555637533904.png)
* 跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗



## 9. 散列表（Hash Table）

* 散列表用的是数组支持按照下标**随机访问**的特性，时间复杂度为**O(1)**。通过散列函数将元素的键值映射为下标，然后将数据存储在数组中对应下标的位置

![1555723182467](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555723182467.png)

### 9.1 散列函数

* 定义为**hash(key)**

  ```java
  int hash(String key){
      string lasttwowords = key.substr(length-2, length)
      int hashvalue = convert lasttwowords to  int-type
      return hashvalue
  }
  ```

* 散列函数的基本要求

  * 散列函数计算得到的散列值是一个非负整数
  * 若key1 = key2,则 hash(key1) = hash(key2)
  * 若key1 ！= key2 ,则 hash(key1) ！= hash(key2)（**几乎不可能，无法完全避免散列冲突**）

### 9.2 散列冲突

* 解决方法：**开放寻址法**和**链表法**

#### 9.2.1 开放寻址法

* 核心思想：若出现了散列冲突，就重新探测一个空闲位置，将其插入。
* 适用范围：数据量比较小，装载因子小的情况下
* **线性探测法**：
  * **插入**数据：x经过hash函数后，被散列的位置已经有数据了，则按顺序往后一个一个找
  * ![1555724125571](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555724125571.png)
  * **查找**数据：通过散列函数求出要查找元素对应的键值，比较数组中下标为散列值的元素和要查找的元素，若相等则最好，若不等，则按顺序往后依次查找。如果遍历到数组的**空闲位置**还没找到，就说明要查找的元素不在散列表中。
  * ![1555724342267](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555724342267.png)
  * **删除**数据：将要删除的元素，标记为**deleted**。当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。
  * ![1555724443164](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555724443164.png)
* **二次探测法**：线性探测每次的步长为1，下标顺序每次加1，二测探测就是每次加上一个**平方数**
* **双重散列法**：简单说，就是用2个散列函数，若用第一个hash函数计算的存储位置已被使用，则使用第二个hash函数

#### 9.2.1 链表法

* 在散列表中，每个“桶（bucket）”或者“槽（slot）会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中
* ![1555724898796](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555724898796.png)
* 插入时间复杂度**O(1)**，查找、删除时间复杂度为**O(k)**，k为链表的长度
* 适用范围：适合存储大对象、大数据量的散列表，有着更加灵活的优化策略

### 9.3 避免低效扩容

![1555812775137](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555812775137.png)

### 9.4 工业级别散列表

![1555813275288](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555813275288.png)



## 10. 哈希算法

* 哈希算法定义：将**任意长度**的二进制值串映射为**固定长度**的二进制值串，这个映射的规则就是**哈希算法**，映射得到的二进制值串就是**哈希值**。
* 哈希算法要求：
  * 从哈希值**不能**反向推导出原始数据
  * 对输入数据非常敏感，哪怕只修改了一个**bit**位，结果也大不相同
  * 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小
  * 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速算出哈希值

### 10.1 安全加密

* 常见的加密算法
  * **MD5**（Message-Digest Algorithm ,  MD5消息摘要算法）
  * **SHA**（Secure Hash Algorithm，安全散列算法）
  * **DES**（Data Encryption Standard，数据加密标准）
  * **AES**（Advanced Encryption Standard，高级加密标准）
* 哈希算法能做到零冲突的原理：**鸽巢原理**（11个鸽子10个巢）

### 10.2 唯一标识

在海量图库中查找一张图片：

​	从图片的二进制码串开头、中间、结尾各取100字节，将这300字节用哈希算法得到哈希字符串，作为图片的唯一标识

### 10.3 数据校验

* BT下载的原理是基于P2P协议的，将文件分为多个文件块，从多个机器上并行下载，所有的文件块下载完成后，再组装成一个完整的电影文件
* 校验方法同上，每个文件块取哈希值，最后对比

### 10.4 散列函数

* 散列函数也是哈希算法的一种应用
* ![1555980301851](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555980301851.png)

### 10.5 负载均衡

* 维护一张映射关系表，内容是客户端IP地址与服务器编号的映射关系
* 通过哈希算法，对客户端IP地址计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号

### 10.6 数据分片

![1555980834995](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555980834995.png)

### 10.7 分布式存储

![1555981008926](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1555981008926.png)

* **一致性哈希算法**：假设我们有 k 个机器，数据的哈希值的范围是 [0, MAX]。将整个范围划分为m个小区间，每台机器负责m/k个小区间。当有新机器加入的时候，我们将某几个小区间的数据搬移到新机器中。



## 11. 树

* 非线性表数据结构

![1556152415623](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556152415623.png)

* 节点的**高度**：节点到叶子节点的最长路径（边数）
* 节点的**深度**：根节点到这个节点所经历的边的个数
* 节点的**层数**：节点的深度 + 1

![1556152609474](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556152609474.png)

### 11.1 二叉树

![1556152756933](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556152756933.png)

* **满二叉树**：编号2，叶子节点都在最底层，除叶子节点外，每个节点都有左右两个子节点

* **完全二叉树**：编号3，叶子节点都在最底下2层，最后一层的叶子节点都**靠左排列**，并且除了最后一层，其他层的节点个数都达到最大。

* 如何存储一个二叉树？

  * **链式存储法**：

    ![1556153228821](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556153228821.png)

  * **顺序存储法**：若节点X存储在下标为i的位置，那么左子节点就是**2*i**，右子节点就是**2 * i +1**。完全二叉树仅仅只浪费了下标为**0**的存储位置，而非完全二叉树会浪费很多

  ![1556153264585](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556153264585.png)

#### 11.1.1 二叉树的遍历

* 遍历方法：**前序遍历**，**中序遍历**，**后序遍历**。
* 时间复杂度：**O(n)**
* 前序遍历：对于树中的任意节点，先打印这个节点，然后再打印他的左子树，最后打印右子树
* 中序遍历：对于树中的任意节点，先打印左子树，再打印本身，最后打印右子树
* 后序遍历：对于树中的任意节点，先打印左子树，再打印右子树，最后打印本身

![1556153660795](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556153660795.png)

```C++
void preOrder(Node* root) {
  if (root == null) return;
  print root // 此处为伪代码，表示打印 root 节点
  preOrder(root->left);
  preOrder(root->right);
}

void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  print root // 此处为伪代码，表示打印 root 节点
  inOrder(root->right);
}

void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  print root // 此处为伪代码，表示打印 root 节点
}
```

### 11.2 二叉查找树

* 特点：支持动态数据的快速插入、删除、查找操作，时间复杂度都为**O(logn)**（与树的高度有关）
* 二叉查找树：要求树中的任意一个节点，其左子树每个节点的值，都要小于这个节点的值，右子树每个节点的值，都要大于这个节点的值

![1556239786654](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556239786654.png)

#### 11.2.1 查找操作

* 先去根节点，若等于就直接返回；若不等于，则根据大小往左子树或者右子树查找![1556239901038](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556239901038.png)

* ```java
  public class BinarySearchTree {
    private Node tree;
  
    public Node find(int data) {
      Node p = tree;
      while (p != null) {
        if (data < p.data) p = p.left;
        else if (data > p.data) p = p.right;
        else return p;
      }
      return null;
    }
  
    public static class Node {
      private int data;
      private Node left;
      private Node right;
  
      public Node(int data) {
        this.data = data;
      }
    }
  }
  ```

#### 11.2.2 插入操作

* 与查找相似，依次比较要插入的数据和节点的大小关系![1556240074332](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556240074332.png)

* ```java
  public void insert(int data) {
    if (tree == null) {
      tree = new Node(data);
      return;
    }
  
    Node p = tree;
    while (p != null) {
      if (data > p.data) {
        if (p.right == null) {
          p.right = new Node(data);
          return;
        }
        p = p.right;
      } else { // data < p.data
        if (p.left == null) {
          p.left = new Node(data);
          return;
        }
        p = p.left;
      }
    }
  }
  ```

#### 11.2.3 删除操作

* 分为三种情况：

  * （1）要删除的节点没有子节点，只要将父节点中，指向要删除节点的指针置为null
  * （2）要删除的节点只有一个子节点，更新父节点中，指向要删除节点的指针，指向要删除节点的子节点
  * （3）要删除的节点有两个子节点，找到这个节点右子树中的最小节点，替换到要删除的节点上。

  ![1556240595596](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556240595596.png)

* 

```java
public void delete(int data) {
  Node p = tree; // p 指向要删除的节点，初始化指向根节点
  Node pp = null; // pp 记录的是 p 的父节点
  while (p != null && p.data != data) {
    pp = p;
    if (data > p.data) p = p.right;
    else p = p.left;
  }
  if (p == null) return; // 没有找到

  // 要删除的节点有两个子节点
  if (p.left != null && p.right != null) { // 查找右子树中最小节点
    Node minP = p.right;
    Node minPP = p; // minPP 表示 minP 的父节点
    while (minP.left != null) {
      minPP = minP;
      minP = minP.left;
    }
    p.data = minP.data; // 将 minP 的数据替换到 p 中
    p = minP; // 下面就变成了删除 minP 了
    pp = minPP;
  }

  // 删除节点是叶子节点或者仅有一个子节点
  Node child; // p 的子节点
  if (p.left != null) child = p.left;
  else if (p.right != null) child = p.right;
  else child = null;

  if (pp == null) tree = child; // 删除的是根节点
  else if (pp.left == p) pp.left = child;
  else pp.right = child;
}

```

#### 11.2.4 其他操作

* 当有重复数据时：
  * 通过链表和支持扩容的动态数组等结构，将值相同的数据存储在同一节点上
  * 将相同的值放在**右子树**，当做大于这个节点的值进行处理

![1556241519616](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556241519616.png)

![1556241528595](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556241528595.png)

![1556241534764](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556241534764.png)

#### 11.2.5 相比散列表的优势

![1556241773737](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556241773737.png)

### 11.3 红黑树

* 平衡二叉查找树：二叉树中任意一个节点的左右子树的高度相差**不能大于1**，完全二叉树、满二叉树都是平衡二叉查找树
* 平衡二叉查找树的初衷：解决普通二叉查找树在插入、删除等动态更新的情况下，出现时间复杂度退化的情况
* 平衡的意思：让树尽可能看上去对称，比较平衡，这样能使整个树的高度相对来说低一些

#### 11.3.1 红黑树的定义

* 根节点是黑色的
* 每个叶子节点都是黑色的**空节点**（NIL），即叶子节点不存储数据（为简化代码设置的）
* 任何相邻的节点都不能同时为红色，即，红色节点是被黑色节点**隔开**的
* 每个节点，从该节点到达其可达叶子节点的所有路径，都包含**相同数目**的黑色节点

画图时，将黑色的、空的叶子节点都省略了

![1556328344786](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556328344786.png)

#### 11.3.2 近似平衡

平衡二叉查找树的高度为**log2n**，若要证明红黑树近似平衡，只要证明高度近似即可

![1556328517617](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556328517617.png)

* 首先，去掉红色节点，将黑色节点接好，易证明仅包含黑色节点的树高度比相同节点的完全二叉树还要小
* 然后，加上红色节点，有一个红色节点必须用一个黑色节点，而黑色节点的最长路径是log2n，那么加入红色节点后，最长路径极限是2log2n

#### 11.3.3 实现

* 左旋：围绕某个节点的左旋
* 右旋：同上
* ![1556415697065](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556415697065.png)

#### 11.3.4 插入操作的平衡调整

* 规定：插入的节点必须是红色的，并且二叉查找树新插入的节点都是放到叶子节点上的
  * 若插入节点的父节点是黑色的，则无需调整
  * 若插入节点的父节点是根节点，则改变颜色，变为黑色
* 调整的两种基础操作：**左右旋转**和**改变颜色**
* ![1556416163832](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556416163832.png)
* ![1556416175382](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556416175382.png)
* ![1556416194739](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556416194739.png)

#### 11.3.5 删除操作的平衡调整

* 平衡调整步骤：
  * 针对删除节点初步调整，保证满足最后一条定义（每个节点，从该节点到达其可达叶子节点的所有路径，都包含**相同数目**的黑色节点）
  * 针对关注节点进行二次调整，保证满足第三条定义（不存在相邻的两个红色节点）
* ![1556416678314](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556416678314.png)
* ![1556416707134](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556416707134.png)
* ![1556416842393](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556416842393.png)
* 针对关注节点进行**二次调整**
  * ![1556417053070](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556417053070.png)
  * ![1556417065609](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556417065609.png)
  * ![1556417101240](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556417101240.png)
  * ![1556417128527](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556417128527.png)![1556417134724](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556417134724.png)





## 12. 堆

### 12.1 堆和堆排序

* 堆排序是一种**原地的**、时间复杂度为**O(nlogn)**的排序
* 堆的定义：
  * 是一个完全二叉树（**除最后一层其余层都是满的，最后一层的节点都靠左排列**）
  * 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值
    * 大于等于时：叫**大顶堆**
    * 小于等于时：叫**小顶堆**

#### 12.1.1 插入数据

* **堆化**：新插入的数据放到堆最后，再进行调整，重新满足堆的特性
* 两种堆化：从下往上 和 从上往下

![1556760683816](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556760683816.png)

```java
public class Heap {
  private int[] a; // 数组，从下标 1 开始存储数据
  private int n;  // 堆可以存储的最大数据个数
  private int count; // 堆中已经存储的数据个数

  public Heap(int capacity) {
    a = new int[capacity + 1];
    n = capacity;
    count = 0;
  }

  public void insert(int data) {
    if (count >= n) return; // 堆满了
    ++count;
    a[count] = data;
    int i = count;
    while (i/2 > 0 && a[i] > a[i/2]) { // 自下往上堆化
      swap(a, i, i/2); // swap() 函数作用：交换下标为 i 和 i/2 的两个元素
      i = i/2;
    }
  }
 }

```

#### 12.1.2 删除元素

* 堆顶存储的就是最大值或者最小值
* 删除流程：将最后一个节点放到堆顶，然后在进行父子比较，互换节点直到满足条件，**自上而下**方法

![1556761198818](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556761198818.png)

```java
public void removeMax() {
  if (count == 0) return -1; // 堆中没有数据
  a[1] = a[count];
  --count;
  heapify(a, count, 1);
}

private void heapify(int[] a, int n, int i) { // 自上往下堆化
  while (true) {
    int maxPos = i;
    if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
    else if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
    else if (maxPos == i) break;
    swap(a, i, maxPos);
    i = maxPos;
  }
}
```

#### 12.1.3 堆排序的实现

* 建堆：（**时间复杂度O(n)**）

  * 时间复杂度计算：

    ![1556762073006](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556762073006.png)

  * **第一种方法**：以插入数据为核心，假设起初只有一个数据，然后将剩余的插入。**从前向后处理，从下往上堆化。**

  * **第二种方法**：**从后向前处理，从上往下堆化**。

  ![img](https://static001.geekbang.org/resource/image/50/1e/50c1e6bc6fe68378d0a66bdccfff441e.jpg)

  ![img](https://static001.geekbang.org/resource/image/aa/9d/aabb8d15b1b92d5e040895589c60419d.jpg)

  ```java
  private static void buildHeap(int[] a, int n) {
    for (int i = n/2; i >= 1; --i) {
      heapify(a, n, i);
    }
  }
  
  private static void heapify(int[] a, int n, int i) {
    while (true) {
      int maxPos = i;
      if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
      else if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
      else if (maxPos == i) break;
      swap(a, i, maxPos);
      i = maxPos;
    }
  }
  ```

* 排序（**时间复杂度O(nlogn)**）

  * 建堆结束之后，已经按照**大顶堆**组织，将堆顶元素与最后一个交换，再对剩下的n-1个元素再次建堆

  * ![1556762357617](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556762357617.png)

  * ```java
    // n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。
    public static void sort(int[] a, int n) {
      buildHeap(a, n);
      int k = n;
      while (k > 1) {
        swap(a, 1, k);
        --k;
        heapify(a, k, 1)
      }
    }
    ```

* **和快速排序的比较**

  * 数据访问的方式没有快排友好：堆排序跳着访问，快排是局部顺序
  * 同样数据，堆排序的交换次数多于快排：建堆会导致原有的有序度降低

![1556762727396](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556762727396.png)



### 12.2 堆的应用

* 优先级队列：从优先级队列中取出优先级最高的元素，相当于取出堆顶元素
  * 合并有序小文件
  * 高性能定时器
* 利用堆求Top-K
  * 静态数据：维护一个大小为K的小顶堆，遍历数组，从数组中取出数据和堆顶元素对比，遍历完成后，堆中即为前K大数据了。**遍历数组O(n)，一次堆化O(logK)，时间复杂度O(nlogK)**。
  * 动态数据：新加入的数据直接和堆顶元素对比，可以立刻返回
* 利用堆求中位数：
  * 静态数据直接排序，第n/2个数据
  * 动态数据：维护两个堆，将小的前半部分数据存在大顶堆中，将大的后半部分数据存在小顶堆中
  * ![1556846047425](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556846047425.png)



## 13. 图

* 非线性表数据结构
* ![1556931961450](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556931961450.png)
* 微博是**有向图**，微信是**无向图**
* 顶点的**入度**：指向这个顶点的边
* 顶点的**出度**：有多少条边以这个顶点为起点指向其他顶点
* ![1556932252148](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556932252148.png)

### 13.1 邻接矩阵存储

![1556932461356](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556932461356.png)

### 13.2 邻接表存储

![1556932648431](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1556932648431.png)

### 13.3 深度和广度优先搜索

* 寻找所有三度好友关系

* ```java
  public class Graph { // 无向图
    private int v; // 顶点的个数
    private LinkedList<Integer> adj[]; // 邻接表
  
    public Graph(int v) {
      this.v = v;
      adj = new LinkedList[v];
      for (int i=0; i<v; ++i) {
        adj[i] = new LinkedList<>();
      }
    }
  
    public void addEdge(int s, int t) { // 无向图一条边存两次
      adj[s].add(t);
      adj[t].add(s);
    }
  }
  ```

#### 13.3.1 广度优先搜索（BFS）

![1557017661452](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1557017661452.png)

* **时间复杂度：O(E)** （其中O(E+V)，E为边的个数，V为顶点的个数，E >= V-1）

* **空间复杂度：O(V) **（空间消耗在几个辅助变量上，存储大小不超过顶点个数）

* ```java
  public void bfs(int s, int t) {
    if (s == t) return;
    boolean[] visited = new boolean[v];
    visited[s]=true;
    Queue<Integer> queue = new LinkedList<>();
    queue.add(s);
    int[] prev = new int[v];
    for (int i = 0; i < v; ++i) {
      prev[i] = -1;
    }
    while (queue.size() != 0) {
      int w = queue.poll();
     for (int i = 0; i < adj[w].size(); ++i) {
        int q = adj[w].get(i);
        if (!visited[q]) {
          prev[q] = w;
          if (q == t) {
            print(prev, s, t);
            return;
          }
          visited[q] = true;
          queue.add(q);
        }
      }
    }
  }
  
  private void print(int[] prev, int s, int t) { // 递归打印 s->t 的路径
    if (prev[t] != -1 && t != s) {
      print(prev, s, prev[t]);
    }
    System.out.print(t + " ");
  }
  ```

  ![1557018183761](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1557018183761.png)

* 图示：

  * ![1557018212131](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1557018212131.png)
  * ![1557018223754](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1557018223754.png)

#### 13.3.2 深度优先搜索（DFS)

* 运用**回溯**思想，适合用**递归**实现

* ![1557018385992](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1557018385992.png)

* ```java
  boolean found = false; // 全局变量或者类成员变量
  
  public void dfs(int s, int t) {
    found = false;
    boolean[] visited = new boolean[v];
    int[] prev = new int[v];
    for (int i = 0; i < v; ++i) {
      prev[i] = -1;
    }
    recurDfs(s, t, visited, prev);
    print(prev, s, t);
  }
  
  private void recurDfs(int w, int t, boolean[] visited, int[] prev) {
    if (found == true) return;
    visited[w] = true;
    if (w == t) {
      found = true;
      return;
    }
    for (int i = 0; i < adj[w].size(); ++i) {
      int q = adj[w].get(i);
      if (!visited[q]) {
        prev[q] = w;
        recurDfs(q, t, visited, prev);
      }
    }
  }
  ```

* **时间复杂度：O(E)**

* **空间复杂度：O(V)**



## 14. 字符串匹配

### 14.1 BF算法（Brute Force）

* 暴力匹配/朴素匹配算法
* 在字符串A中查找字符串B，A为**主串**，B为**模式串**。
* **核心思想：在主串中，检查起始位置是0、1、2...n-m且长度为n的子串，看有没有和模式串匹配的**![1557102568254](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1557102568254.png)
* 最坏时间复杂度是O(n*m)
  * 实际运用中，大部分情况下，模式串和主串的长度不会太长
  * 算法思想简单，不易出错

### 14.2 RK算法（Rabin Karp）

* **核心思想：通过哈希算法将主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小，相同即可**
* ![1557103550534](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1557103550534.png)
* 哈希算法的设计：假设匹配的字符集只有k个字符，我们就用一个k进制的数来表示
* ![1557103843430](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1557103843430.png)
  * 特点：相邻的字符串哈希值计算公式有一定关系
  * ![1557103983311](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1557103983311.png)
  * ![1557103994440](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1557103994440.png)
  * 整体时间复杂度：O(n)
    * 模式串哈希值和每个子串哈希值的比较的时间复杂度O(1)
    * 总共需要比较n-m+1个子串