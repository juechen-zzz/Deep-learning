# 数据结构和算法笔记



* 数据结构是为算法服务的，算法要作用在特定的数据结构之上。

![img](https://static001.geekbang.org/resource/image/91/a7/913e0ababe43a2d57267df5c5f0832a7.jpg)

* 10个数据结构：**数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树**。
* 10个算法：**递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法**。
* 数据结构是“一组数据的存储结构”，算法是“操作数据的一种方法”。



## 1. 复杂度分析

- 事后统计法缺点：依赖环境，受数据规模影响。

```java
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

结论：所有代码的执行时间T(n)与每行代码的执行次数成正比。

```java
 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```

总执行时间为：
$$
2n^2+2n+3
$$

### 1.1 大O公式

$$
T(n)=O(f(n))
$$

第一个例子T(n)=O(2n+2),第二个例子T(n)=O(2n^2+2n+3)。

* 大O时间复杂度并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，也叫渐进时间复杂度，简称时间复杂度。

* 当n很大时，公式中的低阶、常量、系数并不左右增长趋势，只需记录一个最大量级。

* 分析方法：

  * 只关注循环执行次数最多的一段代码。

  * 加法法则：总复杂度等于量级最大的那段代码的复杂度。

  * 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

    ```java
    int cal(int n) {
       int ret = 0; 
       int i = 1;
       for (; i < n; ++i) {
         ret = ret + f(i);
       } 
     } 
     
     int f(int n) {
      int sum = 0;
      int i = 1;
      for (; i < n; ++i) {
        sum = sum + i;
      } 
      return sum;
     }
    ```

### 1.2 复杂度量级

![1554084629522](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554084629522.png)

* 分为**多项式量级**和**非多项式量级**。其中，非多项式量级只有2个：**指数**和**阶乘**。

* 当n越来越大时，非多项式量级算法的执行时间会急剧增加。所以，这是一种低效的算法。

  * **O(1)**:只是常量级时间复杂度的一种表示方法，并不是只执行了一行代码。一般情况下，只要算法中不存在**循环**和**递归**，时间复杂度就是O(1)。

  * **O(logn)**、**O(nlogn)**:

    ```java
     i=1;
     while (i <= n)  {
       i = i * 2;
     }
    ```

    可以看出，变量i的值从1开始，每循环一次就乘以2，实际上就是一个等比数列。![1554085156357](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554085156357.png)

    所以，**x**就是代码执行的次数，时间复杂度为O(log2n)。

    由于对数存在**换底公式**，在采用大O标记复杂度的时候，可以忽略系数。**O(Cf(n)) = O(f(n))**，所以，在对数阶时间复杂度的表示方法中，忽略底数。

  * **O(m+n)**、**O(m*n)**：代码的复杂度由**两个数据**的规模来决定。

    ```java
    int cal(int m, int n) {
      int sum_1 = 0;
      int i = 1;
      for (; i < m; ++i) {
        sum_1 = sum_1 + i;
      }
    
      int sum_2 = 0;
      int j = 1;
      for (; j < n; ++j) {
        sum_2 = sum_2 + j;
      }
    
      return sum_1 + sum_2;
    }
    ```

    可以看出，m和n是两个数据规模，我们事先无法知道m和n谁的量级大，所以，上面代码的时间复杂度就是O(m+n)。**此时，加法法则就不能用了，改为T1(m) + T2(n) = O(f(m) + g(n))；乘法法则依旧有效，T1(m)*T2(n) = O(f(m) * f(n))**。

### 1.3 空间复杂度分析

* 时间复杂度的全称是渐进时间复杂度，表示算法的**执行时间与数据规模**之间的增长关系。
* 空间复杂度的全称是渐进空间复杂度，表示算法的**存储空间与数据规模**之间的增长关系。

```java
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

在第二行代码中，我们申请了一个空间存储变量i，但是它是常量阶的，与数据规模n没有关系。第三行申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以空间复杂度为O(n)。

![1554087085121](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554087085121.png)

### 1.4 最好、最坏情况时间复杂度

```java
int find(int[] array, int n n int x ){
    int i = 0;
    int pos =-1;
    for(; i < n;++i){
        if (array[i] == x) pos =i;
    }
    return pos;
}

// 优化代码
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

* 最好情况时间复杂度：在**最理想**的情况下，执行这段代码的时间复杂度
* 最坏情况时间复杂度：在**最糟糕**的情况下，执行指端代码的时间复杂度

### 1.5 平均时间复杂度

* 要查找的变量x在数组中的位置，有n+1种情况：在数组的**0~n-1位置**中和**不在数组**中。我们把每种情况下，查找需要遍历的元素个数累加起来，再除以n+1：

  ![1554166946205](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554166946205.png)

* 考虑各种情况的概率：

![1554167091827](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554167091827.png)

​	这个值就是概率论中的**加权平均值**，也称为**期望值**。

### 1.6 均摊时间复杂度

* 分析方法：**摊还分析**。

```java
int[] array = new int[n];
int count = 0;

void insert(int val){
    if (count == array.length){
        int sum = 0 ;
        for (int i = 0 ; i < array.length; ++i){
            sum = sum + array[i];
        }
        array[0] = sum;
        count = 1;
    }
    array[count] = val;
    ++count;
}
```

* 最好时间复杂度为O（1），最坏为O（n），平均为O（1）。

![1554169189360](C:\Users\nihaopeng\AppData\Roaming\Typora\typora-user-images\1554169189360.png)

* find()和insert()的区别
  * find()在极端情况下，复杂度为O(1)，insert()在大多数情况下，复杂度为O(1)。
  * 对于 insert() 函数来说，O(1) 时间复杂度的插入和O(n)时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个O(n)插入后，紧跟着n-1个O(1)的插入操作，循环往复。

* **大致思路**：每一次 O(n) 的插入操作，都会跟着n-1次O(1)的插入操作，把耗时多的均摊到接下来的耗时少的n-1次操作上。

* 课后题：

  ```java
  // 全局变量，大小为 10 的数组 array，长度 len，下标 i。
  int array[] = new int[10]; 
  int len = 10;
  int i = 0;
  
  // 往数组中添加一个元素
  void add(int element) {
     if (i >= len) { // 数组空间不够了
       // 重新申请一个 2 倍大小的数组空间
       int new_array[] = new int[len*2];
       // 把原来 array 数组中的数据依次 copy 到 new_array
       for (int j = 0; j < len; ++j) {
         new_array[j] = array[j];
       }
       // new_array 复制给 array，array 现在大小就是 2 倍 len 了
       array = new_array;
       len = 2 * len;
     }
     // 将 element 放到下标为 i 的位置，下标 i 加一
     array[i] = element;
     ++i;
  }
  ```

  该算法的最好情况时间复杂度(best case time complexity)为O(1);
  最坏情况时间复杂度(worst case time complexity)为O(n);
  平均情况时间复杂度(average case time complexity),
  **第一种计算方式**: (1+1+...+1+n)/(n+1) = 2n/(n+1) 【注: 式子中1+1+...+1中有n个1】,所以平均复杂度为O(1);
  **第二种计算方式**(加权平均法，又称期望): 1*(1/n+1)+1*(1/n+1)+...+1*(1/n+1)+n*(1/(n+1))=1，所以加权平均时间复杂度为O(1);
  **第三种计算方式**(均摊时间复杂度): 前n个操作复杂度都是O(1)，第n+1次操作的复杂度是O(n)，所以把最后一次的复杂度分摊到前n次上，那么均摊下来每次操作的复杂度为O(1)